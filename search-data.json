[
    
    
    
        
            {
                "id": 0,
                "href": "https://coder-shin.github.io/post/a/",
                "title": "a",
                "section": "post",
                "date" : "2023.03.24",
                "body": "[[html]]{HTML} a 태그는 앵커(Anchor) 태그라고도 불리며, 웹 페이지 내부에서 특정한 위치로 이동할 때 사용하는 태그이다.\n인용 "
            }
    
        ,
            {
                "id": 1,
                "href": "https://coder-shin.github.io/post/p/",
                "title": "p",
                "section": "post",
                "date" : "2023.03.24",
                "body": "[[html]]{HTML} p 태그는 단락을 만드는 경우 사용하는 태그이다.\n인용 p 태그는 paragraph의 줄임말이빈다. paragraph는 단락을 의미하므로 p 태그를 사용하면 하나의 단락을 만들 수 있습니다.\n(모던 웹을 위한 HTML5+CSS3 바이블[1판] p.45)\n"
            }
    
        ,
            {
                "id": 2,
                "href": "https://coder-shin.github.io/post/comment/",
                "title": "주석(comment)",
                "section": "post",
                "date" : "2023.03.24",
                "body": "[[html]]{HTMl} [[html]]{HTMl}에서 주석(comment) 작성 방법은 아래와 같다.\n\u0026lt;!-- 주석 --\u0026gt; 인용 프로그래밍 언어에서는 프로그램의 실행에 영향을 미치지 않고 설명을 위한 목적으로 사용하는 코드를 \u0026lsquo;주석\u0026rsquo;이라고 부릅니다.\n(모던 웹을 위한 HTML5+CSS3 바이블[1판] p.37)\n"
            }
    
        ,
            {
                "id": 3,
                "href": "https://coder-shin.github.io/post/html/",
                "title": "HTML",
                "section": "post",
                "date" : "2023.03.24",
                "body": "태그 [[a]]{} [[p]]{} 관련 문서 [[comment]]{주석(comment)} 인용 "
            }
    
        ,
            {
                "id": 4,
                "href": "https://coder-shin.github.io/post/array-include/",
                "title": "배열에 특정 값이 존재하는지 확인하기(array include)",
                "section": "post",
                "date" : "2023.03.22",
                "body": "[[javascript]]{자바스크립트(JavaScript)} 여러 방법이 있다. 상황에 맞는 방법을 선택해서 문제를 풀어가도록 하자.\nfor문(혹은 Array.prototype.forEach() 메서드) Array.prototype.indexOf() 메서드 Array.prototype.includes() 메서드 Array.prototype.includes() 메서드의 사용법은 아래와 같다.\n대상_배열.includes(특정_값); 대상_배열에 특정_값이 있는지 확인 후 값이 있는 경우는 true, 없는 경우는 false를 반환한다.\n구체적인 예는 다음과 같다.\nconst animals = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;] console.log(animals.includes(\u0026#39;dog\u0026#39;)); // true console.log(animals.includes(\u0026#39;lion\u0026#39;)); // false 팁 [[javascript]]{JavaScript} - 어느 방법을 사용해서 배열에 특정 값의 포함 관계를 확인할까? 현재(2023) 시점에서는 Array.prototype.includes() 메서드를 이용한 방법이 가장 좋다고 생각된다.\n개인적으로 가독성을 성능 보다 우선시 한다. 그렇기 때문에 포함하는가 라는 의미를 갖고 있는 Array.prototype.includes() 메서드를 사용하는 것이 for문(또는 forEach)을 사용하는 것 보다 좋다고 생각한다.\nArray.prototype.indexOf()을 Array.prototype.includes()와 비슷하게 사용할 경우 놓치기 쉬운 실수(경계값 문제)가 존재하기 때문에 포함 관계를 확인하는데 Array.prototype.indexOf()를 사용하는 것은 좋은 방법이라고 생각하지 않는다.\n이와 같은 이유로 특별한 상황이 아닌 경우 Array.prototype.includes() 메서드를 이용하는 것이 가장 좋다고 생각된다.\n인용 "
            }
    
        ,
            {
                "id": 5,
                "href": "https://coder-shin.github.io/post/object-copy/",
                "title": "객체 복사하기(object copy)",
                "section": "post",
                "date" : "2023.03.21",
                "body": "방법 Object.assign() 메서드 이용하기(Shallow copy) Object.assign()은 객체로부터 대상 객체로 속성을 복사하는 메서드이다.\n단 주의해야하는 점이 2 가지 있다. 첫 번째로 주의해야하는 점은 얕은 복사(Shallow copy)이다. 그렇기 때문에 중첩된 객체를 포함되어 있는 경우 참조값만 복사된다. 구체적인 예는 다음과 같다.\n두 번째로 이 메서드는 새로운 객체를 만들지 않고 대상 객체를 수정한다는 점이다. 구체적인 예는 다음과 같다.\nJSON.parse()와 JSON.stringify() 이용하기(Deep copy) 단 이 방법은 value의 값에 따라서 데이터가 유실, 변경 되는 경우가 발생하기 때문에 주의가 필요하다.\nconst obj = { a: null, b: NaN, c: Infinity, d: undefined, e: function(){}, f: Number, g: false, } const copyObj = JSON.parse(JSON.stringify( obj)) console.log(obj); // { // a: null, // b: NaN, // c: Infinity, // d: undefined, // e: [Function: e], // f: [Function: Number], // g: false // } console.log(copyObj); // { // a: null, // b: null, // c: null, // g: false // } structuredClone() 메서드 이용하기(Deep copy) 단 이 방법은 Node 17 이상의 버전에서만 사용할 수 있다.\nLodash 라이브러리의 cloneDeep() 메서드 이용하기(Deep copy) Underscore.js 라이브러리의 clone() 메서드 이용하기(Deep copy) Ramda 라이브러리의 clone() 메서드 이용하기(Deep copy) 무엇을 사용하는게 좋을까? 만약 사용하고 있는 node의 버전이 17 이상인 경우는 structuredClone()을 사용하면 현재(2023) 기준으로 모든 브라우저에서 문제 없이 사용가능하기 떄문에\n"
            }
    
        ,
            {
                "id": 6,
                "href": "https://coder-shin.github.io/post/dictionary/",
                "title": "딕셔너리(dictionary)",
                "section": "post",
                "date" : "2023.03.21",
                "body": "[[javascript]]{자바스크립트(JavaScript)} [[javascript]]{자바스크립트(JavaScript)}에서 딕셔너리(dictionary) 타입의 [[data structure]]{자료구조(data structure)}를 [[object]]{오브젝트(Object)}라고 칭한다. [[oop]]{OOP(객체 지향 프로그래밍)}에서 칭하는 [[object]]{오브젝트(Object)}와는 전혀 다른 개념을 칭하기 떄문에 조심해서 사용 할 것.\n인용 원칙적으로 객체는 변화가 없고 구조화된 키-값 데이터를 다루는 경우에 유용합니다. 반면에 자주 갱신되거나 실행되기 전에는 알 수 없는 동적인 정보를 다루기에는 적합하지 않습니다.\n(자바스크립트 코딩의 기술[1판] TIP 10 객체를 이용해 정적인 키-값을 탐색하라)\n"
            }
    
        ,
            {
                "id": 7,
                "href": "https://coder-shin.github.io/post/array-copy/",
                "title": "배열 복사하기(array copy)",
                "section": "post",
                "date" : "2023.03.16",
                "body": "깊은 복사(Deep copy)와 얕은 복사(Shallow copy) [[javascript]]{자바스크립트(JavaScript)} [[javascript]]{자바스크립트(JavaScript)}에서 배열을 복사하를 하는 방법은 굉장히 많다. 하나씩 알아보도록 하자.\nArray.prototypeslice (Shallow copy) Array.prototype.slice() 메서드를 사용해서 배열을 복사하는 방법은 다음과 같다.\nconst originalArray = [1, 2, 3, 4, 5]; const copiedArray = originalArray.slice(); copiedArray[0] = 999; console.log(originalArray); // [1, 2, 3, 4, 5] console.log(copiedArray); // [999, 2, 3, 4, 5] 단 배열 내부에 [[reference type]]{참조 타입(reference type)}이 있는 경우 문제가 발생할 수 있다.\nconst originalArray = [1, [2, 3], 4]; const copiedArray = originalArray.slice(); copiedArray[1][0] = 999; console.log(originalArray); // [1, [999, 3], 4] console.log(copiedArray); // [1, [999, 3], 4] 중첩된 [[reference type]]{참조 타입(reference type)}을 복사할 경우 복사본과 원본 사이에 얕은 복사(shallow copy) 관계가 생기는 문제가 생기기 때문에 발생하는 문제이다.\n[[spread operator]]{전개 구문(spread operator)}(Shallow copy) [[spread operator]]{전개 구문(spread operator)}(Shallow copy)를 사용해서 배열을 복사하는 방법은 다음과 같다.\nconst originalArray = [1, 2, 3, 4, 5]; const copiedArray = [...originalArray]; copiedArray[0] = 999; console.log(originalArray); // [1, 2, 3, 4, 5] console.log(copiedArray); // [999, 2, 3, 4, 5] 단 배열 내부에 [[reference type]]{참조 타입(reference type)}이 있는 경우 문제가 발생할 수 있다.\nconst originalArray = [1, [2, 3], 4]; const copiedArray = [...originalArray]; copiedArray[1][0] = 999; console.log(originalArray); // [1, [999, 3], 4] console.log(copiedArray); // [1, [999, 3], 4] 중첩된 [[reference type]]{참조 타입(reference type)}을 복사할 경우 복사본과 원본 사이에 얕은 복사(shallow copy) 관계가 생기는 문제가 생기기 때문에 발생하는 문제이다.\nJSON.parse와 JSON.stringify(Deep copy) 어느 것을 사용하는게 좋을까? 배열 내부에 [[reference type]]{참조 타입(reference type)}이 없다는 확신이 있다면 [[spread operator]]{전개 구문(spread operator)}을 이용하는 것이 가장 좋다고 생각한다.\n왜냐하면 [[spread operator]]{전개 구문(spread operator)} 자체가 굉장히 간결하기 때문에 다른 방법을 이용해 작성하는 것 보다 훨씬 가독성이 좋다고 생각되기 때문이다.\n배열 내부에 [[reference type]]{참조 타입(reference type)}이 존재한다면 JSON.parse와 JSON.stringify를 이용하는것이 가장 간결하다고 생각한다. 단 JSON.parse와 JSON.stringify를 그냥 사용할 경우 무슨 일을 하고 있는지 알 수 없으므로 아래와 같은 함수를 만들어서 그것을 사용하는 것이 가장 좋다고 생각된다.\nconst deepCopy = (targetArray) =\u0026gt; { return JSON.parse(JSON.stringify(targetArray)); } 배열 복사는 언제 사용하면 좋을까? 배열을 복사해서 사용하는 경우는 기존 배열을 유지한채로 배열을 조작하고 싶은 경우에 사용한다고 생각하면 된다.\n인용 "
            }
    
        ,
            {
                "id": 8,
                "href": "https://coder-shin.github.io/post/array-push/",
                "title": "배열의 마지막에 요소 추가하기(array push)",
                "section": "post",
                "date" : "2023.03.15",
                "body": "[[javascript]]{자바스크립트(JavaScript)} 자바스크립트에서 배열의 마지막에 요소를 추가하기 위해서 사용하는 방법은 Array.prototype.push() 메서드를 사용하는 방법과 [[spread operator]]{전개 구문(spread operator)}를 사용하는 방법 크게 두 가지가 있다.\nArray.prototype.push() 메서드를 사용하는 방법은 아래와 같다.\n배열의 마지막에 요소 추가하기 - Array.prototype.push()\nconst array = [1, 2, 3]; array.push(4); console.log(array); // [1, 2, 3, 4] [[spread operator]]{전개 구문(spread operator)}를 사용하는 방법은 아래와 같다.\n배열의 마지막에 요소 추가하기 - [[spread operator]]{전개 구문(spread operator)}\nconst array = [1, 2, 3]; const pushedArray = [...array, 4]; console.log(pushedArray); // [1, 2, 3, 4] console.log(array); // [1, 2, 3] 개인적으로는 기존의 배열을 변경하는 경우(for문을 돌려서 새로운 배열에 값을 넣어주는 경우) 이외는 무조건 [[spread operator]]{전개 구문(spread operator)}를 사용해야 한다는 입장이다. 왜냐하면 Array.prototype.push() 메서드 자체가\n어디에 사용할 수 있을까? 인용 "
            }
    
        ,
            {
                "id": 9,
                "href": "https://coder-shin.github.io/post/spread-in-function-calls/",
                "title": "함수에 인수 전달하기(spread in function calls)",
                "section": "post",
                "date" : "2023.03.15",
                "body": "[[javascript]]{자바스크립트(Javascript)} 함수가 여러 인자를 받는 경우 배열로 전달하고 싶은 경우가 있다.\n예를 들어 Math.max()가 그렇다. 바로 예를 확인해 보자.\nconsole.log(Math.max(1, 2, 3)); // 3 console.log(Math.max([1, 2, 3])); // NaN Function.prototype.apply() 메서드를 사용하면 배열을\nconsole.log(Math.max.apply(null, [1, 2, 3])); // 3 [[spread operator]]{전개 구문(spread operator)}를 사용하면 편리하게\nconsole.log(Math.max(...[1, 2, 3])); // 3 인용 "
            }
    
        ,
            {
                "id": 10,
                "href": "https://coder-shin.github.io/post/array-concat/",
                "title": "배열 합치기(array concat)",
                "section": "post",
                "date" : "2023.03.15",
                "body": "[[javascript]]{자바스크립트(javascript)} [[javascript]]{자바스크립트(JavaScript)}에서 배열을 합치기 위해서 사용하는 방법은 Array.prototype.concat() 메서드를 사용하는 방법과 [[spread operator]]{전개 구문(spread operator)}를 사용하는 방법 크게 두 가지가 있다.\nArray.prototype.concat() Array.prototype.concat() 메서드를 사용하는 방법은 아래와 같다.\n배열 2개를 합치는 방법 - Array.prototype.concat()\nconst array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const combinedArrayWithConcat = array1.concat(array2); console.log(combinedArrayWithConcat); // [1, 2, 3, 4, 5, 6] console.log(array1); // [1, 2, 3] console.log(array2); // [4, 5, 6] 배열 3개를 합치는 방법 - Array.prototype.concat()\nconst array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const array3 = [7, 8, 9]; const combinedArrayWithConcat = array1.concat(array2, array3); console.log(combinedArrayWithConcat); // [1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(array1); // [1, 2, 3] console.log(array2); // [4, 5, 6] console.log(array3); // [7, 8, 9] [[spread operator]]{전개 구문(spread operator)} [[spread operator]]{전개 구문(spread operator)}을 사용해서 배열을 합치는 방법은 아래와 같다.\n배열 2개를 합치는 방법 - [[spread operator]]{전개 구문(spread operator)}\nconst array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const combinedArrayWithSpread = [...array1, ...array2]; console.log(combinedArrayWithSpread); // [1, 2, 3, 4, 5, 6] console.log(array1); // [1, 2, 3] console.log(array2); // [4, 5, 6] 배열 3개를 합치는 방법 - [[spread operator]]{전개 구문(spread operator)}\nconst array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const array3 = [7, 8, 9]; const combinedArrayWithSpread = [...array1, ...array2, ...array3]; console.log(combinedArrayWithSpread); // [1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(array1); // [1, 2, 3] console.log(array2); // [4, 5, 6] console.log(array3); // [7, 8, 9] Array.prototype.concat()와 [[spread operator]]{전개 구문(spread operator)} 어느 것을 사용할까? Array.prototype.concat()를 이용하든 [[spread operator]]{전개 구문(spread operator)}를 이용하든 동일하게 기존 배열의 변화 없이 여러 배열을 합칠 수 있다.\n개인적인 의견으로는 [[spread operator]]{전개 구문(spread operator)}를 사용하기 보다는 Array.prototype.concat() 메서드를 사용하는 것이 좋다고 생각한다. 왜냐하면 [[spread operator]]{전개 구문(spread operator)}는 여러가지 일을 가독성 좋고 심플하게 할 수 있지만, 그 자체는 배열을 합친다는 의미가 없기 때문이다. 즉 [[spread operator]]{전개 구문(spread operator)}을 사용해서 배열을 합치는 경우 명시적으로 배열을 합친다는 의미를 가진 Array.prototype.concat() 메서드와는 다르게 무슨 일을 하고 있는지 확인해볼 필요가 있다. 최대한 명시적으로 무엇을 하고 있는지 나타내는게 가독성이 좋아지기 때문에 배열을 합치는 경우에는 명식적인 의미를 지칭하는 Array.prototype.concat()을 사용하는 것을 추천한다.\n배열 합치기는 언제 사용하면 좋을까? 배열 합치기를 이용하는 경우는 기본적으로 여러 데이터들을 합치는 경우 사용한다고 생각하면 된다.\n구체적으로 사용 할 수 있는 상황은 아래와 같다.\n주소록 합치기: 여러 주소록을 하나의 주소록으로 합치는 경우 배열 합치기를 사용 할 수 있다. 판매 데이터 합치기: 여러 매장의 판매 데이터를 합쳐서 전체 판매 데이터를 만드는 경우 배열 합치기를 사용 할 수 있다. 또한 배열의 합침과 동시에 정렬을 변경, 필터링, 중복 제거 등을 통해서 새로운 데이터를 창출할 수 있기 때문에 배열 합치기의 사용처는 무궁무진하다.\n인용 "
            }
    
        ,
            {
                "id": 11,
                "href": "https://coder-shin.github.io/post/spread-operator/",
                "title": "전개 구문(spread operator)",
                "section": "post",
                "date" : "2023.03.13",
                "body": "[[javascript]]{자바스크립트(JavaScript)} 개요 반복 가능한 객체를 펼치는 연산자.\n사용법 아래와 같은 형태로 사용한다.\n...펼치고_싶은_대상 단 주의해야하는 점은 전개 구문(spread operator)는 단독으로 사용 할 수 없다는 점이다. 전개 구문(spread operator)를 사용한 경우 반드시 펼친 결과를 어디에든 넣어줘야한다.\n[...펼치고_싶은_대상] 사용처 [[array concat]]{배열 합치기(array concat)} [[array copy]]{배열 복사하기(array copy)} 객체 합치기 객체 복사하기 [[spread in function calls]]{함수에 인수 전달하기(spread in function calls)} 주의 배열 이외의 대상에서는 concat과 움직임이 다르다. 인용 이 배열을 펼침 연산자(\u0026hellip;)를 이용해 목록으로 바꿉니다.\nconst cart = [\u0026#39;Naming and Necessity\u0026#39;, \u0026#39;Alice in Wonderland\u0026#39;]; ...cart REPL이나 브라우저 콘솔에서 위의 코드를 실행하면 오류가 발생합니다. 문법은 맞지만 펼침 연산자를 단독으로 사용할 수는 없습니다. 예를 들어 펼침 연산자의 결과를 변수에 할당할 수 없습니다. 정보를 어디든 펼쳐 넣어야 합니다.\n(자바스크립트 코딩의 기술[1판] - tip 7 펼침 연산자로 배열을 본떠라)\n"
            }
    
        ,
            {
                "id": 12,
                "href": "https://coder-shin.github.io/post/annotation/",
                "title": "annotation",
                "section": "post",
                "date" : "2023.03.13",
                "body": "[[java]]{자바(Java)} 인용 어노테이션은 다음 세 가지 용도로 사용된다.\n컴파일러에게 코드 문법 에러를 체크하도록 정보를 제콩 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공 (이것이 자바다[1판]) p.268\n어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수로 다음과 같이 정의되어 있다.\nElementType 열거 상수 적용 대상 TYPE 클래스, 인터페이스, 열거 타입 ANNOTATION_TYPE 어노테이션 FIELD 필드 CONSTRUCTOR 생성자 METHOD 메소드 LOCAL_VARIABLE 로컬 변수 PACKAGE 패키지 (이것이 자바다[1판]) p.271\n사용 용도에 따라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야 한다. 쉽게 설명하면 소스상에만 유지할 건지, 컴파일된 클래스까지 유지할 건지, 런타임 시에도 유지할 건지를 지정해야 한다.\n(이것이 자바다[1판]) p.272\n어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수로 다음과 같이 정의되어 있다.\nRetentionPolicy 열거 상수 설명 SOURCE 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. CLASS 바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다. RUNTIME 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플레션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다. (이것이 자바다[1판]) p.272\n어노테이션 유지 정책을 지정할 때에는 @Retention 어노테이션을 사용한다.\n(이것이 자바다[1판]) p.272\n"
            }
    
        ,
            {
                "id": 13,
                "href": "https://coder-shin.github.io/post/access-modifier/",
                "title": "접근 제한자(access modifier)",
                "section": "post",
                "date" : "2023.03.13",
                "body": "[[java]]{자바(Java)} 사용 이유 접근해서 사용할 수 있는 멤버와 사용할 수 없는 멤버를 구분하기 위해서 사용한다.\n종류 [[java]]{자바(Java)}에서 제공하는 접근 제한자는 아래의 네 가지 종류가 있다.\npublic protected default private 각각의 특징은 아래와 같다.\npublic 접근 제한자를 사용한 멤버는 모든 클래스가 자유롭게 사용 할 수 있다. 즉 자기 자신의 클래스, 같은 패키지의 클래스, 자식 클래스, 외부 클래스가 사용 가능하다.\nprotected 접근 제한자를 사용한 멤버는 같은 패키지와 자식 클래스가 자유롭게 사용 할 수 있다. 즉 자기 자신의 클래스, 같은 패키지의 클래스, 자식 클래스가 사용 가능하다.\nprivate 접근 제한자를 사용한 멤버는 자신 이외의 클래스에서는 사용 할 수 없다. 즉 자기 자신의 클래스만이 사용 가능하다.\ndefault 접근 제한자를 사용한 멤버는 같은 패키지에 소속된 클래스에서 사용 가능하다. 즉 자기 자신의 클래스, 같은 패키지의 클래스가 사용 가능하다. (default 접근 제한자는 public, protected, private 중 어느 제한자도 사용하지 않은 경우 자동적으로 default 접근 제한자에 할당된다.)\n인용 라이브러리 클래스를 설계할 때에는 외부 클래스에서 접근할 수 있는 멤버와 접근 할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다. \u0026hellip; 자바는 이러한 기능을 구현하기 위해 접근 제한자(Access Modifier)를 제공하고 있다.\n(이것이 자바다[1판]) p.256\npublic 접근 제한자는 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다. protected 접근 제한자는 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버를 만든다. private 접근 제한자는 단어의 뜻 그대로 개인적인 것이라 외부에 노출되지 않는 멤버를 만든다. 위 세 가지 접근 제한자가 적용되지 않은 멤버는 default 접근 제한자를 가진다. default 접근 제한자는 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.\n(이것이 자바다[1판]) p.256\n"
            }
    
        ,
            {
                "id": 14,
                "href": "https://coder-shin.github.io/post/import/",
                "title": "임포트(import)",
                "section": "post",
                "date" : "2023.03.13",
                "body": "[[java]]{자바(Java)} 사용 이유 다른 패키지에 속하는 클래스를 사용하기 위해 import를 이용한다.\n위치 import문은 pacakge 선언과 class 선언의 사이에 위치한다.\n* (에스터리스크) 패키지에 포함된 다수의 클래스를 사용해야 한다면 클래스별로 import문을 작성할 필요 없이 클래스 이름을 생략하고 * 를 사용해서 표현 할 수도 있다. 단 개인적인 의견으로는 static 클래스를 제외하고는 import문은 * 로 표현하기 보다는 사용할 클래스를 하나씩, import문을 이용해서 작성하는 것이 좋다고 생각한다. 왜냐하면 * 로 표현되어 있는 경우, 현재의 [[class]]{클래스(class)}와 다른 [[class]]{클래스(class)}간의 [[coupling]]{결합도(coupling)}가 얼마나 높은지 판단 할 수 없다. 그렇기 때문에 [[refactoring]]{리팩터링(refactoring)}의 판단 기준이 될 수 있는 [[coupling]]{결합도(coupling)}가 눈에 보이지 않게 된다. 결과적으로는 코드가 점점 냄새나는 코드로 변화한다.\n인용 "
            }
    
        ,
            {
                "id": 15,
                "href": "https://coder-shin.github.io/post/package/",
                "title": "package",
                "section": "post",
                "date" : "2023.03.12",
                "body": "[[java]]{자바(java)} 명명 규칙 언어상 규칙 숫자로 시작하면 안된다. _ 와 $를 제외한 특수 문자는 사용하면 안된다. java로 시작하면 안된다. (java로 시작하는 패키지는 자바 표준 API에서만 사용되어야 하기 때문이다.) 관례적 규칙 모두 소문자로 작성한다. 회사의 도메인의 역순으로 패키지를 작성한다. 마지막 패키지는 프로젝트 이름을 붙여준다. "
            }
    
        ,
            {
                "id": 16,
                "href": "https://coder-shin.github.io/post/static/",
                "title": "static",
                "section": "post",
                "date" : "2023.03.11",
                "body": "[[java]]{자바(java)} 클래스를 생성하지 않은 상태에서 사용할 수 있는 멤버, 메소드를 생성하게 해주는 기능\n인용 정적(static)은 \u0026lsquo;고정된\u0026rsquo;이란 의미를 가지고 있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. (이것이 자바다[1판]) p.236\n필드를 선언할 때 인스턴스 필드로 선언할 것인가, 아니면 정적 필드로 선언할 것인가의 판단 기준은 객체마다 가지고 있어야 할 데이터라면 인스턴스 핀드로 선언하고, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다. (이것이 자바다[1판]) p.236\n메소드의 경우, 인스턴스 메소드로 선언할 것인가, 아니면 정적 메소드로 선언할 것인가의 판단 기준은 인스턴스 필드를 이ㅛㅇ해서 실행해야 한다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다. (이것이 자바다[1판]) p.237\n"
            }
    
        ,
            {
                "id": 17,
                "href": "https://coder-shin.github.io/post/enum/",
                "title": "열거(enum)",
                "section": "post",
                "date" : "2023.03.09",
                "body": "[[java]]{자바(Java)} 특징 한정된 값만을 가진다. 열거 상수는 객체이다. 관례 열거 상수는 대문자로 작성한다. 관련 메소드 name() 열거 객체가 가지고 있는 문자열을 리턴하는 메소드. 열거 타입을 정의 할 때 사용한 상수 이름과 동일한 값을 리턴 ordinal() 열거 객체 중 몇 번째 열거 객체인지를 리턴하는 메소드. 순번은 0번 부터 시작한다. compareTo() 열거_객체.compareTo(비교_대상_열거_객체)의 형태로 사용한다. 열거_객체가 비교_대상_열거_객체를 기준으로 몇 번째 위치하는지를 비교한다. 비교_대상_열거_객체보다 열거_객체가 앞에 위치한 경우 음수(-)가 리턴된다. valueOf() 열거_객체_타입.valueOf(문자열)의 형태로 사용된다. 주어진 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다. values() 배열에 열거 타입의 모든 열거 객체들을 넣어서 리턴하는 메소드. 예시 기본 사용법 public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } 인용 한정된 값만을 갖는 데이터 타입이 열거 타입(enumeration type)이다. (이것이 자바다[1판]) p.171\n열거 상수는 열거 타입의 값으로 사용되는데, 관례적으로 열거 상수는 모두 대문자로 작성한다. (이것이 자바다[1판]) p.171\n"
            }
    
        ,
            {
                "id": 18,
                "href": "https://coder-shin.github.io/post/jvm/",
                "title": "JVM(Java Virtual Machine)",
                "section": "post",
                "date" : "2023.03.07",
                "body": "나의 해석 특징 Java가 한 번의 코드 작성으로 어느 OS에서든 동일하게 작동하게 해주는 고마운 소프트웨어 JVM 자체는 OS에 종속적이다. JVM을 한 번 거치기 때문에 Java는 하드웨어에 맞게 컴파일된 C 언어에 비해서 느리다.(단 JIT 컴파일러와 최적화로 속도가 많이 빨라졌다.) 인용 JVM은 \u0026lsquo;Java virtual machine\u0026rsquo;을 줄인 것으로 직역하면 \u0026lsquo;자바를 실행하기 위한 가상 기계\u0026rsquo;라고 할 수 있다. (자바의 정석 p.4)\n일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데 비해 Java애플리케이션은 JVM을 한 번 더 거치기 때문에, 그리고 하드웨어 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 가지고 있다. (자바의 정석 p.5)\n"
            }
    
        ,
            {
                "id": 19,
                "href": "https://coder-shin.github.io/post/string/",
                "title": "string",
                "section": "post",
                "date" : "2023.03.07",
                "body": "[[java]]{Java} 팁 [[java]]{Java} - 문자열을 비교할 때 equals()을 사용할까? ==를 사용할까? equals() 메소드를 사용하는 것이 타당하다고 본다.\n개인적인 경험으로 이야기 하자면 문자열을 new 생성자를 이용해서 생성을 하는게 좋은 이유가 한번도 타당해 보인적이 없었다. 그렇기 때문에 개인적으로 문자열을 생성할 때 new 연산자를 이용해서 생성하지 않는다. 이 경우는 ==를 사용해도 문제가 없다.\n하지만 프로그래밍은 대부분 혼자하지 않는다. 그렇기 때문에 받은 문자열이 new 연산자를 이용해서 작성되지 않았다고 100% 보장을 할 수 없다. 이런 경우 ==를 이용해서 코딩을 한 경우 어디서 예측하지 못한 결과가 나올지는 아무도 알 수 없다. 그렇기 때문에 처음부터 equals() 메서드를 이용해서 코드를 작성하는 것이 안전하다고 이야기 할 수 있다.\n인용 동일한 문자열 리터럴로 String 객체를 생성했을 경우 == 연산의 결과는 true가 나오지만, new 연산자로 String 객체를 생성했을 경우 == 연산의 결과는 false가 나온다. == 연산자는 변수에 저장된 객체 번지가 동일한지를 검사하기 때문이다. (이것이 자바다[1판]) p.147\n동일한 String 객체이건 다른 String 객체이건 상관없이 문자열만을 비교할 때에는 String 객체의 equals() 메소드를 사용해야 한다. (이것이 자바다[1판]) p.147\n"
            }
    
        ,
            {
                "id": 20,
                "href": "https://coder-shin.github.io/post/array/",
                "title": "배열(array)",
                "section": "post",
                "date" : "2023.03.07",
                "body": "[[java]]{자바(Java)} 특징 선언과 동시에 저장할 수 있는 데이터 타입이 결정 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다. new 연산자를 이용해서 배열을 생성한 경우 배열의 값들은 기본값으로 초기화된다. [[javascript]]{자바스크립트(JavaScript)} 특징 일반적으로 불리는 \u0026ldquo;배열(array)\u0026rdquo; 데이터 타입이라기 보다는 \u0026ldquo;리스트(list)\u0026rdquo; 데이터 타입에 가깝다. 각종 사용법 [[array push]]{배열의 마지막에 요소 추가하기(array push)} [[array concat]]{배열 합치기(array concat)} [[array copy]]{배열 복사하기(array copy)} [[array include]]{배열에 특정 값이 존재하는지 확인하기(array include)} [[spread in function calls]]{함수에 배열 인수 전달하기(spread in function calls)} 인용 같은 타입의 많은 양의 데이터를 다루는 프로그램에서는 좀 더 효율적인 방법이 필요한데 이것이 배열이다. 배열은 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다. (이것이 자바다[1판]) p.150\n"
            }
    
        ,
            {
                "id": 21,
                "href": "https://coder-shin.github.io/post/include/",
                "title": "include",
                "section": "post",
                "date" : "2023.03.07",
                "body": "특정 값이 존재하는지 확인하기\n[[javascript]]{JavaScript} [[array]]{배열}에 특정 값이 존재하는지 확인하는 방법 [[array include]]{배열에 특정 값이 존재하는지 확인하기} 문서를 참고할 것.\n인용 "
            }
    
        ,
            {
                "id": 22,
                "href": "https://coder-shin.github.io/post/template-literals/",
                "title": "template literals",
                "section": "post",
                "date" : "2023.03.02",
                "body": "정리 백틱(back-tick)을 이용한다. 중괄호 내부에서 많은 것을 하는 것은 가독성이 좋지 않으므로 하지 말 것. 예시 const helloKr = \u0026#39;안녕\u0026#39;; const helloEn = \u0026#39;hello\u0026#39;; const greet = (greetingLang) =\u0026gt; (name) =\u0026gt; `${greetingLang}, ${name}` const greetKr = greet(helloKr); const greetEn = greet(helloEn); const greetToKorean = (name) =\u0026gt; { return greetKr(name); } const greetToEnglish = (name) =\u0026gt; { return greetEn(name); } console.log(greetToKorean(\u0026#39;철수\u0026#39;)); console.log(greetToEnglish(\u0026#39;John\u0026#39;)); const generatePlaceholder = (width, height) =\u0026gt; `http://placehold.it/${width}x${height}` 인용 첫쨰, 템플릿 리터럴은 따옴표 또는 쌍따옴표 대신 백틱(back-tick)()을 사용합니다. 둘째. 변수에 할당한 문자열 처럼 단순 문자열이 아니라면 특별한 지정자로 감싸야 합니다. ${stuff}` 처럼 $ 기호와 중괄호로 변수나 다른 자바스크립트 코드를 감싸는 것입니다. (자바스크립트 코딩의 기술[1판] - tip 4 템플릿 리터럴로 변수를 읽을 수 있는 문자열로 변환하라)\n가급적이면 중괄호 내부에서 많은 것을 하지 않는 것이 좋습니다. 코드가 필요 이상으로 어수선해지기 때문입니다. (자바스크립트 코딩의 기술[1판] - tip 4 템플릿 리터럴로 변수를 읽을 수 있는 문자열로 변환하라)\n"
            }
    
        ,
            {
                "id": 23,
                "href": "https://coder-shin.github.io/post/list/",
                "title": "list",
                "section": "post",
                "date" : "2023.03.02",
                "body": "인용 리스트는 비어 있거나, 머리(head)와 꼬리(tail)로 나뉜다. 머르 부분은 하나의 값을 담으며, 꼬리 부분은 그 자체로 다시 리스트다. (처음 배우는 엘릭서 프로그래밍[1판] p.70)\n"
            }
    
        ,
            {
                "id": 24,
                "href": "https://coder-shin.github.io/post/solid/",
                "title": "SOLID",
                "section": "post",
                "date" : "2023.02.28",
                "body": "SOLID를 이루는 다섯 가지 원칙 SRP: 단일 책임 원칙(Single Responsibility Principle) OCP: 개방/폐쇄 원칙(Open/Close Principle) LSP: 리스코프 대체 원칙(Liskov Substitution Principle) ISP: 인터페이스 분리 원칙(Interface Segregation Principle) DIP: 의존성 반전 원칙(Dependency Inversion Principle) 각종 인용 SOLID를 이루는 다섯 가지 원칙은 다음과 같다.\nSRP: 단일 책임 원칙(Single Responsibility Principle) OCP: 개방/폐쇄 원칙(Open/Close Principle) LSP: 리스코프 대체 원칙(Liskov Substitution Principle) ISP: 인터페이스 분리 원칙(Interface Segregation Principle) DIP: 의존성 반전 원칙(Dependency Inversion Principle) (객체지향 사고 프로세스[5판] p.xxi) "
            }
    
        ,
            {
                "id": 25,
                "href": "https://coder-shin.github.io/post/encapsulation/",
                "title": "캡슐화(encapsulation)",
                "section": "post",
                "date" : "2023.02.28",
                "body": "[[inheritance]]{상속}을 이용하면 캡슐화가 약해진다. 상속을 사용하면 아래와 같은 부작용이 있다.\n슈퍼클래스의 구현부를 변경하면 모든 서브 클래스에 영향을 끼친다. 슈퍼클래스에 상속 받은 내용을 변경하면 그 클래스로 부터 상속 받은 모든 서브 클래스에 영향을 끼치게 된다. 그 결과 서브 클래스는 슈퍼 클래스에 크게 영향을 받게 되며 뿐 아니라 슈퍼 클래스는 의도치 않게 서브 클래스에 영향을 주는 형태가 되어 결과적으로는 객체의 캡슐화가 약해지게 된다.\n각종 인용 동일한 엔티티에서 특성들과 메서드들을 한 곳으로 합침으로 써, Math 객체의 데이터에 대한 접근을 제어할 수 있다. (객체지향 사고 프로세스[5판] p.7)\n길버트와 맥커티는 캡슐화를 \u0026lsquo;프로그램을 이루고 있는 각 클래스를 인터페이스와 임플리멘테이션이라는 두 가지 뚜렷한 부분으로 나누는 과정\u0026rsquo; (객체지향 사고 프로세스[5판] p.143)\n슈퍼클래스에서 구현부를 상속한 후에 해당 구현부를 변경해 버리면 이러한 슈퍼클래스 내의 변경 내용이 클래스 위계구조를 통해 파급된다는 점이다. (객체지향 사고 프로세스[5판] p.7)\n캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다. (이것이 자바다 p.189)\n"
            }
    
        ,
            {
                "id": 26,
                "href": "https://coder-shin.github.io/post/inheritance/",
                "title": "상속(inheritance)",
                "section": "post",
                "date" : "2023.02.28",
                "body": "상속을 이용하면 [[encapsulation]]{캡슐화}가 약해진다. 상속을 사용하면 아래와 같은 부작용이 있다.\n슈퍼클래스의 구현부를 변경하면 모든 서브 클래스에 영향을 끼친다. 슈퍼클래스에 상속 받은 내용을 변경하면 그 클래스로 부터 상속 받은 모든 서브 클래스에 영향을 끼치게 된다. 그 결과 서브 클래스는 슈퍼 클래스에 크게 영향을 받게 되며 뿐 아니라 슈퍼 클래스는 의도치 않게 서브 클래스에 영향을 주는 형태가 되어 결과적으로는 객체의 [[encapsulation]]{캡슐화}가 약해지게 된다.\n각종 인용 상속(inheritance)을 통해 클래스는 그 밖의 클래스들이 지닌 속성과 메서드를 물려받을 수 있다. (객체지향 사고 프로세스[5판] p.25)\n오늘날에는 행위(behaviors)를 인터페이스 안에 기술해 두는 경향이 있으며, 속성들을 상송하는 게 직접 상속의 가장 일반적인 용례 (객체지향 사고 프로세스[5판] p.26)\n상속은 is-a 관계로 간주되고 합성은 has-a 관계로 간주된다. (객체지향 사고 프로세스[5판] p.34)\n상속 트리를 따라 내려갈수록 사물들이 더 특수화된다는(specific, 즉 더 구체화된다는) 생각이다. \u0026ldquo;\u0026hellip; \u0026quot; 상속이라는 개념을 설명하자면 상속이란 공통된 성질을 배제해 자가면서 일반화에서 특수화로 나아가는 일이다. (객체지향 사고 프로세스[5판] p.137)\n"
            }
    
        ,
            {
                "id": 27,
                "href": "https://coder-shin.github.io/post/polymoriphism/",
                "title": "다형성(polymoriphism)",
                "section": "post",
                "date" : "2023.02.28",
                "body": "각종 인용 다형성(polymoriphism)은 문자 그대로 다양한 형상(shapes)을 의미하는 그리스 단어다. (객체지향 사고 프로세스[5판] p.29)\n다형성이란 비슷한 객체가 다른 방식으로 동일한 메시지에 응답 할 수 있음을 의미한다. (객체지향 사고 프로세스[5판] p.34)\n다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. (이것이 자바다 p.190)\n"
            }
    
        ,
            {
                "id": 28,
                "href": "https://coder-shin.github.io/post/composition/",
                "title": "합성(composition)",
                "section": "post",
                "date" : "2023.02.28",
                "body": "각종 인용 어떤 객체를 종종 그 밖의 객체들을 사용해 구축하거나 합성할 수 있는데, 이것이 합성이라는 개념이다. (객체지향 사고 프로세스[5판] p.34)\n상속은 is-a 관계로 간주되고 합성은 has-a 관계로 간주된다. (객체지향 사고 프로세스[5판] p.34)\n합성(composition)이란 다른 클래스를 사용해 더 복잡한 클래스, 즉 일종의 어셈블리(assemblies, 즉 \u0026lsquo;조립체\u0026rsquo;)를 구축하는 작업이 포함된다. 이 경우에 부모/자식 관계가 없다. 기본적으로 복합 객체(complex objects)는 그 밖의 객체들을 가지고 합성한 것이다. (객체지향 사고 프로세스[5판] p.132)\n"
            }
    
        ,
            {
                "id": 29,
                "href": "https://coder-shin.github.io/post/scope/",
                "title": "scope",
                "section": "post",
                "date" : "2023.02.27",
                "body": "나의 해석 인용 "
            }
    
        ,
            {
                "id": 30,
                "href": "https://coder-shin.github.io/post/error/",
                "title": "error",
                "section": "post",
                "date" : "2023.02.26",
                "body": "에러를 처리하는 방법 에러가 발생할 가능성이 있지만 무시한다. 에러가 발생할 가능성이 있는 코드를 수정한다. 런타임시 에러를 우아하게 핸들링한다. 에러를 던진다. 각종 인용 \u0026laquo;Java Primer Plus\u0026raquo;의 11장에서 프로그램에서 탐지된 문제를 처리하는 데 세 가지 기본적인 해결책이 있다고 기술했다. 바로 수정하거나, 스퀠칭(squelching)으로 문제를 무시하거나, 런타임(프로그램 실행 중)에 어떤 우아한 방법을 사용해 오류를 퇴출하는 것이다. (객체지향 사고 프로세스[5판] p.64 ~ p.65)\n\u0026laquo;Object-Oriented Design in Java\u0026raquo;의 4장에서 길버트와 맥커티는 예외를 던지는 선택지를 추가함으로써 이 주제를 넓혀 주었다. (객체지향 사고 프로세스[5판] p.65)\n"
            }
    
        ,
            {
                "id": 31,
                "href": "https://coder-shin.github.io/post/construct/",
                "title": "construct",
                "section": "post",
                "date" : "2023.02.26",
                "body": "나의 해석 각종 인용 지금은 \u0026lsquo;생성자\u0026rsquo;라는 말이 정착되었지만, 영어단어의 의미를 더 정확히 전달하는 번역어는 \u0026lsquo;구성자\u0026rsquo;다. \u0026hellip; construct는 \u0026rsquo;\u0026rsquo; (객체지향 사고 프로세스[5판] p.55)\n"
            }
    
        ,
            {
                "id": 32,
                "href": "https://coder-shin.github.io/post/constructor/",
                "title": "생성자(constructor)",
                "section": "post",
                "date" : "2023.02.26",
                "body": "나의 해석 다중 생성자 vs 단일 생성자 각종 인용 지금은 \u0026lsquo;생성자\u0026rsquo;라는 말이 정착되었지만, 영어단어의 의미를 더 정확히 전달하는 번역어는 \u0026lsquo;구성자\u0026rsquo;다. \u0026hellip; construct는 \u0026lsquo;구성체\u0026rsquo;라는 철학 용어로 번역할 수 있는 말이다. 그러므로 구성자를 통해서 클래스를 일종의 구성체로 만든다는 의미이며, 이처럼 구성체가 된 클래스는 객관(objection)의 대상이 되므로 객관체(object)라고 부를 수 있으며, 이를 줄여서 \u0026lsquo;객체\u0026rsquo;라고 부르는 것이다. (객체지향 사고 프로세스[5판] p.55)\n아마도 생성자의 가장 중요한 기능은 new 키워드가 발견될 때 할당된 메모리를 초기화하는 일일 것이다. 즉 생성자에 포함된 코드는 새로 생성된 객체를 초기의 안정적이고 안전한 상태가 되게 정해 주어야 한다. (객체지향 사고 프로세스[5판] p.57)\n클래스에 항상 생성자를 한 개 이상 두는 게 좋은 프로그래밍 습관이다. 클래스에 속성이 있는 경우라면 항상 초기화하는 게 좋다. 객체지향 여부에 관계없이 코드를 작성할 때면 무조건 변수를 변수를 초기화하는게 언제나 좋은 습관이다. (객체지향 사고 프로세스[5판] p.57)\n생성자의 역할은 객체 생성 시 초기화를 담당한다. (이것이 자바다 p.197)\n생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다 (이것이 자바다 p.204)\n"
            }
    
        ,
            {
                "id": 33,
                "href": "https://coder-shin.github.io/post/class/",
                "title": "class",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 각종 인용 클래스란 객체의 설계도다. (객체지향 사고 프로세스[5판] p.16)\n"
            }
    
        ,
            {
                "id": 34,
                "href": "https://coder-shin.github.io/post/methods/",
                "title": "메서드(methods)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 [[java]]{자바(Java)} 네이밍 숫자로 시작하면 안된다. $ 와 _ 를 제외한 특수 문자를 사용할 수 없다. 관례적으로 메소드명은 소문자로 시작한다. 서로 다른 단어가 혼합된 이름은 camelCase로 작성한다. 인용 객체의 행위(behaviors)는 객체가 할 수 있는 일을 나타낸다. 절차적 언어에서 행위는 프로시저(procedures)와 함수(functions) 및 서브루틴(subroutines) 형식으로 정의한다. 객체지향 프로그래밍 용어로 표현하자면 이러한 행위라는 용어는 메서드(methods)라는 용어로 아우를 수 있는데, (객체지향 사고 프로세스[5판] p.11)\n매소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다. (이것이 자바다 p.197)\n"
            }
    
        ,
            {
                "id": 35,
                "href": "https://coder-shin.github.io/post/attributes/",
                "title": "속성(attributes)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 속성의 종류 속성의 종류는 3가지 존재한다.\n지연적인 속성 객체의 속성 클래스의 속성 각종 인용 객체 내에 저장된 데이터는 객체의 상태를 나타낸다. 객체지향 프로그래밍 용어에서 이 데이터를 속성(attributes)이라고 한다. (객체지향 사고 프로세스[5판] p.10)\n"
            }
    
        ,
            {
                "id": 36,
                "href": "https://coder-shin.github.io/post/object/",
                "title": "객체(object)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 객체는 속성(attributes)과 행위(methods)를 가진 엔티티다.\n[[javascript]]{자바스크립트(JavaScript)} [[javascript]]{자바스크립트(JavaScript)}에서의 객체는 [[oop]]{OOP(객체 지향 프로그래밍)}에서 이야기하는 객체와는 달리 키-값 데이터를 가지는 [[dictionary]]{딕셔너리(dictionary)} 타입의 [[data structure]]{자료구조(data structure)}이다.\n객체 복사하기 [[object copy]]{객체 복사하기(object copy)}\n각종 인용 객체는 속성과 행위라는 두 가지 성분으로 정의된다.\n(객체지향 사고 프로세스[5판] p.5)\n객체에 대한 기본적인 정의에 따르자면 객체란 데이터와 행위라는 양면(both)을 포함하는 엔티티(entity)다.\n(객체지향 사고 프로세스[5판] p.5)\n객체에는 속성을 나타내는데 사용되는 정수 및 문자열과 같은 엔터티(entities)가 들어 있지만, 행위를 나타내는 메서드(methods)도 들어 있다. 더 중요한 것은 객체의 멤버(속성 멤버와 메서드 멤버)에 대한 접근을 제어할 수 있다는 점이다.\n(객체지향 사고 프로세스[5판] p.7)\n원칙적으로 객체는 변화가 없고 구조화된 키-값 데이터를 다루는 경우에 유용합니다. 반면에 자주 갱신되거나 실행되기 전에는 알 수 없는 동적인 정보를 다루기에는 적합하지 않습니다.\n(자바스크립트 코딩의 기술[1판] TIP 10 객체를 이용해 정적인 키-값을 탐색하라)\n"
            }
    
        ,
            {
                "id": 37,
                "href": "https://coder-shin.github.io/post/object-wrappers/",
                "title": "객체 래퍼(object wrappers)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 캡슐화의 연장선으로 코드를 객체 지향에 적합하게 숨기는 행위\n무엇을 객체로 둘러싸는가? 구조적 코드 이식하기 어려운 코드(네이티브 코드) 기존 클래스(자신이 마음대로 변경 할 수 없는 코드) 각종 인용 객체 래퍼(object wrappers)는 다른 코드를 둘러싸는 객체지향 코드다. (객체지향 사고 프로세스[5판] p.4)\n"
            }
    
        ,
            {
                "id": 38,
                "href": "https://coder-shin.github.io/post/fp/",
                "title": "함수형 프로그래밍(FP)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 [[OOP]]{OOP} =\u0026gt; 인싸 FP =\u0026gt; 아싸\n각종 인용 "
            }
    
        ,
            {
                "id": 39,
                "href": "https://coder-shin.github.io/post/oop/",
                "title": "객체 지향 프로그래밍(OOP)",
                "section": "post",
                "date" : "2023.02.25",
                "body": "나의 해석 OOP =\u0026gt; 인싸 [[fp]]{FP} =\u0026gt; 아싸\n중요 개념 객체지향 언어의 경우 아래의 개념이 모두 구현 가능하다.\n[[encapsulation]]{캡슐화(encapsulation)} [[inheritance]]{상속(inheritance)} [[polymoriphism]]{다형성(polymoriphism)} [[composition]]{합성(composition)} 관련 용어 [[object]]{객체(object)} [[object wrappers]]{객체 래퍼(object wrappers)} [[attributes]]{속성(attributes)} [[methods]]{메서드(methods)} [[class]]{클래스(class)} [[constructor]]{생성자(constructor)} [[encapsulation]]{캡슐화(encapsulation)} [[inheritance]]{상속(inheritance)} [[polymoriphism]]{다형성(polymoriphism)} [[composition]]{합성(composition)} [[SOLID]]{SOLID} 각종 인용 역사적으로 객체지향 언어는 캡슐화와 상속 및 다형성으로 정의되어 왔다(필자는 이것을 \u0026lsquo;고전적인\u0026rsquo; 객체지향이라고 부른다). 따라서 어떤 한 언어가 이러한 측면들을 모두 구현하지 않으면 일반적으로 개체지향적 언어가 아닌 것으로 간주한다. 필자는 이 세 가지 개념을 혼합한 것 외에도 항상 합성이라는 개념도 추가해 넣는다. (객체지향 사고 프로세스[5판] p.2)\n객체 지향 프로그래밍(OOP:Object Oriented Programming)은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법이다. (이것이 자바다 p.189)\n"
            }
    
        ,
            {
                "id": 40,
                "href": "https://coder-shin.github.io/post/select/",
                "title": "SELECT",
                "section": "post",
                "date" : "2023.02.24",
                "body": "기본 사용법 SELECT 문은 테이블에서 데이터를 꺼낼 때 사용하는 [[SQL]]문이다. 기본 구문은 아래와 같다.\nSELECT \u0026lt;열명\u0026gt;, ... FROM \u0026lt;테이블명\u0026gt;; 모든 열을 출력하고 싶은 경우 모든 열을 출력하고 싶으면 별표(*)를 사용하면 된다.\nSELECT * FROM \u0026lt;테이블명\u0026gt;; 단 굉장히 많은 데이터가 담겨져 있는 테이블에서 위의 구문을 실행하면 리소스를 굉장히 사용하기 때문에 위의 구문을 사용하기 보다는 필요한 열만을 지정해서 출력하도록 하자. 혹은 limit를 지정해서 일정량의 데이터만 가져오도록 하자.\n중복을 제외하고 출력하기 DISTINCT 키워드를 이용하면 중복을 제외한 결과를 출력한다.\nSELECT DISTINCT \u0026lt;열 명\u0026gt; FROM \u0026lt;테이블명\u0026gt;; 복수의 열을 조합한 경우, 조합한 결과가 동일한 행이 하나의 행으로 모아져 출력된다.\nDISTINCT를 사용할 때 NULL도 하나의 데이터로 인식된다.\nWHERE WEHRE문을 이용하면 조건부에 부합하는 행만을 출력할 수 있다. 구문은 아래와 같다.\nSELECT \u0026lt;열명\u0026gt;, ... FROM \u0026lt;테이블명\u0026gt; WHERE \u0026lt;조건식\u0026gt;; WHERE 구는 FROM 구 바로 뒤에 둔다.\n각종 인용 SELECT 문은 많은 SQL 문 중에서도 가장 자주 사용되며 가장 기본이 되는 구문이다. SELECT 문을 마스터하는 것은 곧 SQL 문 전체를 마스터하는 것이라 해도 과언이 아니다. (SQL 더 쉽게 더 깊게 p.37)\n"
            }
    
        ,
            {
                "id": 41,
                "href": "https://coder-shin.github.io/post/null/",
                "title": "null",
                "section": "post",
                "date" : "2023.02.24",
                "body": "[[database]]{데이터베이스(database)} 산술 연산자와 같이 사용하는 경우 NULL을 포함한 계산은 무조건 NULL이 된다.\n예를 들어 아래의 연산 결과는 전부 NULL이다.\n10 + NULL NULL + 10 10 - NULL NULL - 10 10 * NULL NULL * 10 10 / NULL NULL / 10 NULL / 0 비교 연산자와 같이 사용하는 경우 인용 null은 값이 존재하지 않는게 아니라 상태를 알 수 없음이다. (옆자리의 동료)\n많은 프로그래밍 언어에서 null 값은 아무것도 아닌 값을 나타낸다. 이것은 난해한 개념처럼 보이지만, 속성을 아무것도 설정하지 않는 것은 유용한 프로그래밍 기술이다. 변수가 null인지를 확인해서 값이 제대로 초기화되었는지를 확인할 수 있기 때문이다. (객체지향 사고 프로세스[5판] p.87)\n"
            }
    
        ,
            {
                "id": 42,
                "href": "https://coder-shin.github.io/post/complement/",
                "title": "보수(complement)",
                "section": "post",
                "date" : "2023.02.23",
                "body": "팁 컴퓨터는 보수를 더하는 방법으로 뺄셈을 구현한다. 각종 설명 보수(complement)는 반대로 세는 수입니다. (독하게 시작하는 C 프로그래밍(1판) p.38)\n컴퓨터는 2진법을 사용하며, 진법문제와 상관없이 보수를 더하는 방법으로 뺄셈을 구현하기 때문입니다. (독하게 시작하는 C 프로그래밍(1판) p.38)\n"
            }
    
        ,
            {
                "id": 43,
                "href": "https://coder-shin.github.io/post/recursion/",
                "title": "순환(recursion)",
                "section": "post",
                "date" : "2023.02.23",
                "body": "용어 설명 나의 해석 큰 문제를 작은 문제로 나누어서 해결하는 방법\n각종 설명 순환(recursion)이란 어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다. (C언어로 쉽게 풀어쓴 자료구조(3판))\n장단점 장점 [[[반복문(loop)]]]을 사용하면 복잡해지는 문제들을 간단하게 해결 할 수 있다. 문제의 정의가 순환적으로 되어 있는 경우 순환으로 작성하는 것이 훨씬 더 간결하게 코드를 작성 할 수 있다. 단점 실행시간이 오래걸린다. 메모리 사용에 있어서 비효율적이다. 꼬리 순환과 머리 순환 꼬리 순환(tail recursion) return n * factorial(n - 1); 머리 순환(head recursion) return factorial(n - 1) * n; 팁 순환은 본질적으로 순환(recursive)인 문제나 그러한 자료구조를 다루는 프로그램에 적합 머리 순환(head recursion)의 경우나 여러 군데에서 자기 자신을 호출하는 경우(multi recursion)는 쉽게 반복전인 코드로 바꿀 수 없다. 대부분 [[반복문(loop)]]로 대처할 수 있다. "
            }
    
        ,
            {
                "id": 44,
                "href": "https://coder-shin.github.io/post/javascript%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B0%80-%EC%96%B4%EB%96%A4-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/",
                "title": "javascript를 이용해서 사용자가 어떤 디바이스를 사용해서 접속하고 있는지 알아보기",
                "section": "post",
                "date" : "2023.02.17",
                "body": "빠른 결론 사용하는 브라우저에 따라서 javascript로 어떤 디바이스를 사용하고 있는지 알아보는 방법이 구현되어 있지 않는 가능성이 있기 때문에, 디바이스를 대상으로 기능을 구현하기 보다는 보고 있는 브라우저의 사이즈에 따라서 기능을 달리하는 방법이 추천된다.\nnavigator.userAgent를 이용하는 방법 navigator.userAgent는 user agent를 string으로 보관하고 있는 읽기 전용 property이다. 이를 이용해서 사용자가 pc에서 페이지를 열람하고 있는가, 스마트폰에서 페이지를 열람하고 있는가를 확인할 수 있다.\nconst isSmartPhone = (): boolean =\u0026gt; { return /Android|iPhone/i.test(navigator.userAgent); }; 간편하게 이용할 수 있는 반면 아래와 같은 단점이 있다.\n사용자가 navigator.userAgent를 위조가 가능하다. 호환성이 좋지 않다. (참고 - https://caniuse.com/mdn-api_navigator_useragentdata) 특히 호환성이 굉장히 좋지 않기 때문에 사용하기 전에 검토를 해볼 필요가 있다.\ndetectmobilebrowsers에서 제공하는 스크립트를 이용하는 방법. http://detectmobilebrowsers.com/ 는 페이지를 어떠한 환경에서 작동하고 있는지 감지 할 수 있는 스크립트를 제공하는 사이트이다.\n편하게 스크립트를 받아서 자신의 서비스에 넣어주면 편리하게 사용가능하다.\n단 몇몇 기기에서 작동이 되지 않는다는 제보도 있기 때문에 100% 신용은 금물이다.\n"
            }
    
        ,
            {
                "id": 45,
                "href": "https://coder-shin.github.io/post/data-type/",
                "title": "데이터형(data type)",
                "section": "post",
                "date" : "2023.02.17",
                "body": "프로그래밍에서의 데이터형(data type) 각종 설명 C 언어의 자료형(data type)은 일정 크기(혹은 길이)의 메모리에 저장된 정보(혹은 자료)를 해석하는 방법이라고 정의할 수 있습니다. 그리고 자료(data)란 수(number)입니다. (독하게 시작하는 C 프로그래밍(1판) p.35)\n[[database]]{데이터베이스}에서의 데이터형(data type) INTEGER형 정수를 넣기 위한 데이터형. 소수는 넣을 수 없다.\nCHAR형 CHARACTER(문자)의 약자.\n문자열을 넣기 위한 데이터형.\nCHAR(10), CHAR(1000)과 같이 괄호를 이용해서 열 안에 넣을 수 있는 문자열의 최대 길이를 지정 가능.\n고정 문자열이다. 고정 문자열에 관한 예를 들면, CHAR(10)을 지정한 열에 \u0026lsquo;hello\u0026rsquo;를 넣었다고 가정하자. 이때 열에는 \u0026lsquo;hello \u0026lsquo;(hello + 공백 5자)가 저장된다.\nVARCHAR형 VARING(가변) CHARACTER(문자)의 약자.\n문자열을 넣기 위한 데이터형.\n가변 문자열이다. 즉 CHAR형과 다르게 최대 길이보다 작은 공간을 공백으로 채우지 않는다.\nDATE형 날짜(년월일)를 저장하는 데이터형(날짜형)이다.\n"
            }
    
        ,
            {
                "id": 46,
                "href": "https://coder-shin.github.io/post/dcl/",
                "title": "DCL",
                "section": "post",
                "date" : "2023.02.17",
                "body": "용어 설명 나의 해석 DCL(Data Control Language)은 데이터베이스에 관한 권한을 제어하는 SQL문이다.\nCOMMIT, ROLLBACK은 TCL(Transaction Control Language)이라고 분류하기도 한다.\n각종 설명 DCL(데이터 제어 언어)은 데이터베이스에서 처리한 변경 내용을 확정하거나 취소하기 위한 것이다. 또한, RDBMS 사용자에게 처리 권한을 부여하기도 한다.\n(SQL 더 쉽게 더 깊게 p.15)\n종류 COMMIT : 변경 내용 확정 ROLLBACK : 변경 내용 취소 GRANT : 권한 부여 REVOKE : 권한 제거\n"
            }
    
        ,
            {
                "id": 47,
                "href": "https://coder-shin.github.io/post/dml/",
                "title": "DML",
                "section": "post",
                "date" : "2023.02.17",
                "body": "나의 해석 DML(Data Manipulation Language)은 테이블의 행을 조작하는 SQL문이다. 특징으로는 WHERE문을 사용 할 수 있다.\n각종 인용 DML(데이터 조작 언어)은 테이블의 행을 검색하거나 변경하기 위한 것이다.\n(SQL 더 쉽게 더 깊게 p.15)\n종류 INSERT : 등록 [[SELECT]] : 조회 UPDATE : 갱신 DELETE : 삭제\n"
            }
    
        ,
            {
                "id": 48,
                "href": "https://coder-shin.github.io/post/ddl/",
                "title": "DDL",
                "section": "post",
                "date" : "2023.02.17",
                "body": "용어 설명 나의 해석 DDL(Data Defintion Language)은 데이터베이스 및 테이블을 생성, 삭제 하기 위해 사용하는 SQL문이다.\n특징으로는 WHERE문을 사용 할 수 없다.\n각종 설명 DDL(데이터 정의 언어)은 데이터를 저장하는 데이터베이스 및 테이블을 생성 삭제하기 위한 것이다.\n(SQL 더 쉽게 더 깊게 p.15)\n간략 설명 CREATE : 생성 DROP : 삭제 ALTER : 변경\n상세 설명 CREATE CREATE문은 데이터베이스, 테이블을 작성할 때 사용하는 [[SQL]]문이다. 기본 구문은 아래와 같다.\n데이터베이스를 생성하는 CREATE DATABASE문\nCREATE DATABASE \u0026lt;데이터베이스명\u0026gt; 테이블을 생성하는 CREATE TABLE문\nCREATE TABLE \u0026lt;테이블\u0026gt; (\u0026lt;열명1\u0026gt; \u0026lt;데이터형\u0026gt; \u0026lt;열의 제약\u0026gt;, \u0026lt;열명2\u0026gt; \u0026lt;데이터형\u0026gt; \u0026lt;열의 제약\u0026gt;, \u0026lt;열명3\u0026gt; \u0026lt;데이터형\u0026gt; \u0026lt;열의 제약\u0026gt;, ... \u0026lt;테이블의 제약1\u0026gt;, \u0026lt;테이블의 제약2\u0026gt;, \u0026lt;테이블의 제약3\u0026gt;, ...); DROP DROP문은 테이블을 삭제 할 때 사용하는 [[SQL]]문이다. 기본 구문은 아래와 같다.\n테이블을 삭제하는 DROP TABLE문\nDROP TABLE \u0026lt;테이블명\u0026gt;; 명심해야하는 점은 \u0026lsquo;삭제한 데이터베이스, 테이블은 복구할 수 없다.\u0026rsquo; 반드시 조심해야한다.\nALTER ALTER문은 테이블의 정의를 변경하는 사용하는 [[SQL]]문이다.\n열 추가 테이블의 열을 추가할 때 사용하는 ALTER TABLE문\nALTER TABLE \u0026lt;테이블명\u0026gt; ADD COLUMN \u0026lt;열 정의\u0026gt;; 주의) Oracle과 SQL Server의 열을 추가하는 경우 COLUMN을 빼고 작성한다.\nOracle과 SQL Server에서의 테이블의 열을 추가할 때 사용하는 ALTER TABLE문\nALTER TABLE \u0026lt;테이블명\u0026gt; ADD \u0026lt;열 정의\u0026gt;; 열 삭제 테이블의 열을 삭제하는 ALTER TABLE 문\nALTER TABLE \u0026lt;테이블명\u0026gt; DROP COLUMN \u0026lt;열명\u0026gt;; 주의) Oracle에서 열을 삭제하는 경우 COLUMN을 빼고 작성한다.\nOracle에서 테이블의 열을 삭제하는 ALTER TABLE 문\nALTER TABLE \u0026lt;테이블명\u0026gt; DROP \u0026lt;열명\u0026gt;; 테이블 이름 변경 테이블의 이름 변경은 표준 SQL이 존재하지 않기 때문에 각 DBMS 마다 구문이 다르다. 각각의 구문은 아래와 같다.\nOracle, PostgreSQL ALTER TABLE \u0026lt;대상 테이블\u0026gt; RENAME TO \u0026lt;변경하고 싶은 이름\u0026gt;; DB2 RENAME TABLE \u0026lt;대상 테이블\u0026gt; TO \u0026lt;변경하고 싶은 이름\u0026gt;; SQL Server sp_rename \u0026#39;\u0026lt;대상 테이블\u0026gt;\u0026#39;, \u0026#39;\u0026lt;변경하고 싶은 이름\u0026gt;\u0026#39;; MySQL RENAME TABLE \u0026lt;대상 테이블\u0026gt; TO \u0026lt;변경하고 싶은 이름\u0026gt;; "
            }
    
        ,
            {
                "id": 49,
                "href": "https://coder-shin.github.io/post/sql/",
                "title": "SQL",
                "section": "post",
                "date" : "2023.02.17",
                "body": "SQL(Structured Query Language)란? 나의 해석 데이터베이스를 조작하기 위한 특정 도메인 언어.\n각종 설명 SQL(Structured Query Language)은 관계형 데이터베이스(이하, 데이터베이스)를 제어하기 위한 언어다.\n(SQL 더 쉽게 더 깊게 p.14)\nSQL문의 종류 SQL문의 종류는 세 가지로 분류한다.\n[[DDL]]{DDL(Data Defintion Language)} [[DML]]{DML(Data Manipulation Language)} [[DCL]]{DCL(Data Control Language)} 각각의 내용은 각가의 링크를 참조할 것.\n관련링크 [[DDL]]{DDL(Data Defintion Language)} [[DML]]{DML(Data Manipulation Language)} [[DCL]]{DCL(Data Control Language)} "
            }
    
        ,
            {
                "id": 50,
                "href": "https://coder-shin.github.io/post/dbms/",
                "title": "DBMS",
                "section": "post",
                "date" : "2023.02.17",
                "body": "DBMS란? 나의 해석 DBMS란 데이터베이스를 관리하는 컴퓨터 소프트웨어이다.\n각종 설명 [[database]]{데이터베이스}를 관리하는 컴퓨터 시스템을 데이터베이스 관리 시스템(Database Management System)이라 하고, 줄여서 DBMS라고도 한다.\n(SQL 더 쉽게 더 깊게 p.4)\nDBMS를 이용하는 이유 다수의 사람들과 데이터를 공유하기 쉽다. 대량의 데이터를 다루기 쉽다. 별도의 프로그래밍 기술이 필요하지 않다. 만일의 사고에 대응할 수 있다. 팁 데이터베이스랑 DBMS가 같은게 아닌가? 상호 교환적으로 사용되기도 하지만 명백하게 이야기하면 다르다. 아래의 인용문을 읽어보자.\n[[database]]{데이터베이스(DB)}와 DBMS는 자주 같은 의미로 사용되기도 한다. 이 책에서는 저장할 데이터 집합을 데이터베이스, 그것을 관리하는 시스템을 DBMS라고 구별한다.\n(SQL 더 쉽게 더 깊게 p.4)\n"
            }
    
        ,
            {
                "id": 51,
                "href": "https://coder-shin.github.io/post/%EC%88%98%ED%96%89%EC%8B%9C%EA%B0%84-%EC%B8%A1%EC%A0%95%EB%B0%A9%EB%B2%95/",
                "title": "수행시간 측정방법",
                "section": "post",
                "date" : "2023.02.16",
                "body": "각 언어별 사용법 [[c]]{C} clock() 함수 이용하기 #include \u0026lt;time.h\u0026gt; start = clock(); // 여기에 수행시간을 측정하고 싶은 코드 삽입 stop = clock(); double duration = (dobule)(stop - start) / CLOCKS_PER_SEC; clock() 함수는 호출 프로세스에 의하여 사용된 CPU 시간을 계산하는 함수 clock() 함수의 반환 단위는 CLOCKS_PER_SEC\ntime() 함수 이용하기 #include \u0026lt;time.h\u0026gt; start = time(NULL); // 여기에 수행시간을 측정하고 싶은 코드 삽입 stop = time(NULL); double duration = (double) difftime(stop, start); time() 함수는 초 단위로 측정된 시간을 반환한다.\n팁 수행시간 측정시 고려해야하는 것들 알고리즘을 비교할 때에는 동일한 하드웨어를 사용해서 측정을 해야한다. 비효율적인 프로그램이라도 슈퍼컴퓨터에서는 빠르게 동작 할 수 있으므로 동일한 하드웨러를 사용해야한다. 사용한 소프트 웨어를 동일하게 해야한다. 동일한 알고리즘이라도 C언어에서 작동하는 알고리즘과 Python에서 작동하는 알고리즘의 속도가 다를 수 있기 때문에 동일한 소프트웨어를 사용해야한다. 실험에 사용한 데이터와 다른 데이터를 사용한 경우 완전히 다른 결과가 나올 수 있다. 입력 자료의 개수가 적을 때에는 효율적이지만 개수가 많아지면 비효율적인 알고리즘이 있기 때문에 자료마다 다른 결과가 나온다. 이와 반대로 입력 자료가 적을 때에는 비효율적이지만 일정 개수를 넘으면 효율적으로 작동하는 알고리즘도 존재하기 때문이다. "
            }
    
        ,
            {
                "id": 52,
                "href": "https://coder-shin.github.io/post/c/",
                "title": "c",
                "section": "post",
                "date" : "2023.02.16",
                "body": "나의 해석 과거의 선인들의 위대한 지식을 얻기 위해 필요한 언어\n인용 팁 [[수행시간 측정방법]] 관련 링크 [[variable]]{변수(variable)} "
            }
    
        ,
            {
                "id": 53,
                "href": "https://coder-shin.github.io/post/database/",
                "title": "데이터베이스(database)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "나의 해석 여러 정보를 유용하게 사용하기 위해서 정리한 것을 데이터베이스라고 생각한다.\n인용 이런 정보를 데이터로 저장하고, 컴퓨터를 사용해서 효율적으로 접근할 수 있도록 가공한 것을 데이터베이스(Database) 또는 줄여서 DB라고 한다.\n(SQL 더 쉽게 더 깊게 p.4)\n명명 규칙 데이터베이스나 테이블, 열 등의 이름으로 사용할 수 있는 문자는 세 가지\n영문자 숫자 언더바( _ ) 이름의 첫 글자는 반드시 영문이어야 한다.\n이름은 중복해서 사용해서는 안 된다.\n관련 링크 [[DBMS]] [[SQL]] [[data type]]{데이터형} "
            }
    
        ,
            {
                "id": 54,
                "href": "https://coder-shin.github.io/post/loop/",
                "title": "반복문(loop)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "용어 설명 나의 해석 반복문은 특정 횟수(for), 특정 조건(while)을 달성할 때 까지 \u0026lsquo;반복\u0026rsquo;하는 문(statement)이다.\n각종 설명 [[조건문(conditional statement)]]{조건문}에는 if문, switch문이 있고 반복문에는 for문, while문, do-while문이 있다. 제어문 블록이 실행 실행 완료되었을 경우 다시 제어문 처음으로 돌아갈지, 아니면 제어문 블록을 빠져나와 정상 흐름으로 다시 돌아올지는 어떤 제어문을 사용하는냐에 달려 있다. [[조건문(conditional statement)]]{조건문}일 경우는 정상 흐름으로 돌아오지만, 반복문일 경우는 제어문 처음으로 다시 되돌아가 반복 실행한다. (이것이 자바다[1판] p.108)\n팁 대부분 [[순환(recursion)]]으로 대체 할 수 있다. "
            }
    
        ,
            {
                "id": 55,
                "href": "https://coder-shin.github.io/post/conditional-statement/",
                "title": "조건문(conditional statement)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "용어 설명 나의 해석 조건문은 \u0026lsquo;조건\u0026rsquo;에 따라 코드의 실행을 취사선택 할 수 있게 해주는 문(statement)이다.\n각종 설명 조건문에는 if문, switch문이 있고 [[반복문(loop)]]{반복문}에는 for문, while문, do-while문이 있다. 제어문 블록이 실행 실행 완료되었을 경우 다시 제어문 처음으로 돌아갈지, 아니면 제어문 블록을 빠져나와 정상 흐름으로 다시 돌아올지는 어떤 제어문을 사용하는냐에 달려 있다. 조건문일 경우는 정상 흐름으로 돌아오지만, [[반복문(loop)]]{반복문}일 경우는 제어문 처음으로 다시 되돌아가 반복 실행한다. (이것이 자바다[1판] p.108)\n팁 "
            }
    
        ,
            {
                "id": 56,
                "href": "https://coder-shin.github.io/post/control-flow-statement/",
                "title": "제어문(control flow statement)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "용어 설명 나의 해석 제어문은 코드의 흐름을 \u0026lsquo;제어\u0026rsquo;하는 문(statement)이다.\n각종 설명 실행 흐름을 개발자가 원하는 방향으로 바꿀 수 있도록 해주는 것이 흐름 제어문이다. 흐름 제어문을 간단히 제어문이라고 한다. \u0026hellip; 제어문의 종류는 [[조건문(conditional statement)]]{조건문}과 [[반복문(loop)]]{반복문}이 있는데, (이것이 자바다[1판] p.108)\n팁 "
            }
    
        ,
            {
                "id": 57,
                "href": "https://coder-shin.github.io/post/constant/",
                "title": "상수(constant)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "용어 설명 나의 해석 상수는 변하지 않는 변수이다.\n각종 설명 프로그램에서는 상수를 \u0026ldquo;값을 한 번 저장하면 변경할 수 없는 변수\u0026quot;로 정의 (이것이 자바다[1판]) p.32\n팁 변하지 않는 상수라고? 이게 무슨 헛소리인가. 변수 vs 상수 왠만한 상황에서는 상수를 사용하는 것을 추천한다.\n변수는 언제 변해도 상관이 없기 때문에 첫줄에 사용한 변수와 그 다음 줄의 변수가 100% 동일하다고 보증을 할 수 없다. 그렇기 때문에 코드를 읽을 때에는 정신 집중해서 읽어야만 한다. (물론 코드를 읽을 때는 집중을 해야하지만) 하지만 상수의 경우 첫줄의 상수와 10000번째 줄의 상수가 100% 동일하다고 보장을 할 수 있기 때문에 편안하게 코드를 읽을 수 있다. 고로 될 수 있는한 상수를 사용해서 코드를 작성하는 것이 가독성적인 측면에서 유리하다.\n"
            }
    
        ,
            {
                "id": 58,
                "href": "https://coder-shin.github.io/post/literal/",
                "title": "리터럴(literal)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "용어 설명 나의 해석 각종 설명 소스 코드 내에서 직접 입력된 값을 리터럴이라고 부른다. (이것이 자바다[1판]) p.32\n숫자의 구체적인 값이 확정되어 앞으로 변할 가능성이 없는 수를 상수라하며 (독하게 시작하는 C 프로그래밍(1판) p.36)\n변수는 그릇이고 상수는 그릇에 담을 음료수이다. (독하게 시작하는 C 프로그래밍(1판) p.37)\n팁 "
            }
    
        ,
            {
                "id": 59,
                "href": "https://coder-shin.github.io/post/java/",
                "title": "java",
                "section": "post",
                "date" : "2023.02.16",
                "body": "나의 해석 큰 회사에서 필요한 그 언어\n특징 운영체제에 독립적이다. 한 번 작성한 코드는 어디에서든 실행된다. 객체지향언어 GC(Garbage Collector)이 존재한다. 인용 팁 관련 링크 [[variable]]{변수(variable)} [[jvm]]{JVM(Java Virtual Machine)} [[string]]{문자열(string)} [[array]]{배열(array)} [[enum]]{열거(enum)} [[static]]{static} [[package]]{패키지(package)} [[import]]{임포트(import)} [[annotation]]{어노테이션(annotation)} "
            }
    
        ,
            {
                "id": 60,
                "href": "https://coder-shin.github.io/post/variable/",
                "title": "변수(variable)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "나의 정의 변수란 하나의 값을 저장하기 위한 이름을 가진 공간.\n[[c]]{C} 명명법 필수 규칙 영문 대/소문자, _ (언더바), 숫자로 만들어야 한다. 첫 글자는 숫자가 될 수 없다. 중간에 공백 문자(빈 칸이나 탭 등)를 넣을 수 없다. 예약어는 사용할 수 없다. [[java]]{자바(Java)} 특징 변수는 선언된 블록 내에서만 사용이 가능하다. 변수는 문(statement)을 통해 만들어진 블록 내에서만 사용이 가능하다.\nif(true) { int insideBlockVariable = 10; System.out.println(insideBlockVariable); // 참조 가능 } System.out.println(insideBlockVariable); // 참조 불가 =\u0026gt; 에러 발생 명명법 필수 규칙 첫 번째 글자는 문자이거나 $, _ 이어야 하고 숫자로 시작할 수 없다. 가능: person, $likeJquery 불가능: 123hello, #likeInsta 영어 대소문자가 구분 camelCase와camelcase는 다른 변수로 취급된다. 예약어는 변수명으로 사용 할 수 없다. while, if 등은 사용 불가 관례 첫 문자는 영어 소문자로 시작하며 camel case를 사용한다. hello, helloMyFriend 상수 변수의 이름은 pascal case를 사용해서 작성한다. final MAX_VALUE [[javascript]]{자바스크립트(JavaScript)} 특징 var, let, const [[javascript]]{자바스크립트(JavaScript)}에는 변수를 할당하기 위해 아래의 세 가지 키워드를 사용한다.\nvar let const 팁 명백한 이름의 변수명을 작성 할 것 명백한 이름의 변수명을 작성하는 것은 코드의 가독성을 높이기 위한 첫걸음이라고 할 수 있다.\n일반적으로 코드는 작성하는 시간보다 읽고 이해하는데 시간이 많이 소요된다. 이 때 변수명이 명확하지 않은 코드 베이스의 경우 변수명이 명확한 코드 베이스를 읽는데 소모하는 시간과 에너지의 몇배는 더 사용해야지만 이해할 수 있다. 명확한 변수명을 사용한 경우 사용하지 않아도 되는 시간과 에너지를 사용한 꼴이다. 또한 새로운 멤버를 영입한 경우에도 변수명이 잘 정리되어 있는 경우, 빠르게 이해해 곧장 전력인 될 가능성도 높아진다.\n이와 같은 이유로 코드 베이스를 더욱 빠르게 이해하고, 생산성을 높이기 위해서 명백한 이름의 변수명을 작성하도록 하자.\n줄임말은 최대한 피해라 예를들어 iLoveHer 이라는 변수명을 ilh라고 줄였다고 가정하자. 코드를 읽는 다른 사람은 iLoveHer인지 iLeaveHere인지 Interscholastic League of Honolulu인지 분간은 할 수가 없다. 좋은 텍스트 에디터나 IDE 있다면, 코드 자동 완성이 됨으로 타이핑이 귀찮다고 줄임말을 쓰는 행위는 삼가하도록 하자. 만약 좋은 텍스트 에디터를 모르겠다면 VSC, vim, Emacs 중에 골라 쓰자. (난 vim이나 emacs 쓸거다.)\n관례적으로 줄임말을 사용하는 변수들은 줄임말을 사용 할 것 예를 들어 for문 안에 사용하는 i와 같이 관례적으로 줄임말을 사용하는 경우는 줄임말을 사용할 것. for문 안의 i를 index라고 표현해도 가독성이 올라가지 않는다. 오히려 내가 i가 index의 약자 인지도 모르는 바보 취급 당하는 것 같아서 자존심이 상하기도 한다.\n인용 프로그램은 작업을 처라하는 과정에서 필요에 따라 데이터를 메모리에 저장한다. 이때 변수를 사용하는데, 변수(varialbe)는 값을 저장할 수 있는 메모리의 공간을 의미한다. \u0026hellip; 변수에는 복수 개의 값을 저장할 수 없고, 하나의 값만 저장할 수 있다.\n변수란, 하나의 값을 저장할 수 있는 메모리 공간이다.\n(이것이 자바다[1판]) p.30\n구체화하지 않았거나 앞으로 변경될 가능성이 있는 수를 변수라 합니다. (독하게 시작하는 C 프로그래밍(1판) p.36)\nconst는 블록의 문맥 내에서 재할당할 수 없는 변수 선언입니다. 즉. 한 번 선언하면 변경할 수 없습니다. (자바스크립트 코딩의 기술[1판] - tip 1 const로 변하지 않는 값을 표현하라)\n값을 할당하고 변경하지 않을 것이라는 점을 표시하면, 미래의 개발자(여러분 자신이 될 수도 있습니다)에게 다음 사실. 즉 코드를 훑어볼 때 해당 변수를 신경 쓰지 않아도 된다고 알려줄 수 있습니다. (자바스크립트 코딩의 기술[1판] - tip 1 const로 변하지 않는 값을 표현하라)\nconst에 할당된 값이 불변값이 되지는 않는다는 것입니다. 즉, 변수를 재할당할 수는 없지만, 값을 바꿀 수 는 있습니다. (자바스크립트 코딩의 기술[1판] - tip 1 const로 변하지 않는 값을 표현하라)\nvar는 어휘적 유효 범위(lexical scope)를 따르는 반면, let은 블록 유효 범위(block scope)를 따릅니다. (자바스크립트 코딩의 기술[1판] - tip 1 const로 변하지 않는 값을 표현하라)\n"
            }
    
        ,
            {
                "id": 61,
                "href": "https://coder-shin.github.io/post/words/",
                "title": "용어(words)",
                "section": "post",
                "date" : "2023.02.16",
                "body": "몰랐던 단어나 개념을 모아둔 곳\n프로그래밍 관련 언어 [[attributes]]{속성(attributes)} [[class]]{클래스(class)} [[conditional statement]]{조건문(conditional statement)} [[constant]]{상수(constant)} [[constructor]]{생성자(constructor)} [[control flow statement]]{제어문(control flow statement)} [[enum]]{열거(enum)} [[error]]{오류(error)} [[list]]{리스트(list)} [[literal]]{리터럴(literal)} [[loop]]{반복문(loop)} [[methods]]{메소드(methods)} [[null]]{null} [[object wrappers]]{객체 래퍼(object wrappers)} [[object]]{객체(object)} [[recursion]]{[순환(recursion)]} [[scope]]{범위(scope)} [[static]]{static} [[string]]{문자열(string)} [[variable]]{변수(variable)} [[package]]{패키지(pacakge)} [[import]]{임포트(import)} [[access modifier]]{접근 제한자(access modifier)} [[annotation]]{어노테이션(annotation)} 수학 관련 언어 [[complement]]{보수(complement)} "
            }
    
        ,
            {
                "id": 62,
                "href": "https://coder-shin.github.io/post/data-structure/",
                "title": "자료구조(data structure)",
                "section": "post",
                "date" : "2023.02.15",
                "body": "리스트 [[object]]{오브젝트(Object)}: [[javascript]]{자바스크립트(JavaScript)}의 [[dictionary]]{딕셔너리(Dictionary)} [[dictionary]]{딕셔너리(Dictionary)} 인용 "
            }
    
        ,
            {
                "id": 63,
                "href": "https://coder-shin.github.io/post/sites/",
                "title": "사이트(sites)",
                "section": "post",
                "date" : "2023.02.15",
                "body": "자료 검색 구글( https://www.google.com ) 유튜브( https://www.youtube.com ) "
            }
    
        ,
            {
                "id": 64,
                "href": "https://coder-shin.github.io/post/books/",
                "title": "책(books)",
                "section": "post",
                "date" : "2023.02.15",
                "body": "ACTIVE 책상에서 읽을 책들 이것이 자바다[1판]\n분야: 프로그래밍 언어 작가: 신용권 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026ldquo;좀 깊은 내용까지 들어가기 때문에 처음 배우는 사람은 어렵게 느껴질 수 있다.\u0026rdquo;] 완료: [] SQL 더 쉽게, 더 깊게[1판]\n분야: 데이터베이스 작가: 미크 저 / 김완섭 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 이동시 읽을 책들 인스파이어드[1판] 분야: 사고(思考) 작가: 마틱 케이건 저 / 황진수 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 장점: [\u0026quot;\u0026quot;] 완료: [] TODO 구입 완료 C를 배우기 전에 반드시 알아야 할 것들[1판]\n분야: 컴퓨터 작가: 무라야마 유키오 저 / 이해란 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] C언어로 쉽게 풀어쓴 자료구조[3판]\n분야: 자료구조 + 알고리즘 작가: 천인국, 공용해, 하상호 별점: 회독: 0 읽을 타이밍: 장점: [\u0026ldquo;수학에 대해 깊이 고민\u0026rdquo;] 단점: [\u0026ldquo;연습 문제 해답이 없다.\u0026rdquo;, \u0026ldquo;코딩 스타일이 중구난방이다.\u0026rdquo;, \u0026ldquo;테스트 안 한게 분명하다.\u0026rdquo;] 완료: [] 독하게 시작하는 C 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 최효성 별점: 회독: 0 읽을 타이밍: 장점: [\u0026ldquo;굉장히 자세하게 설명 되어있다.\u0026rdquo;] 장점: [\u0026ldquo;굉장히 자세하게 설명 되어 있기 때문에 처음 배우는 사람은 어렵게 느껴질 수 있다.\u0026rdquo;] 완료: [] 클릭하세요 리눅스 쉘 스크립트 프로그래밍[1판]\n분야: 도구 작가: 송인우 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 장점: [\u0026quot;\u0026quot;] 완료: [] 객체지향 사고 프로세스[5판]\n분야: 설계 작가: 맷 와이스펠드 저 / 박진수 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 셸 스크립트 - 101가지 예제로 정복하는[1판]\n분야: 도구 작가: Dave Taylor 저 / 여인춘 역 / 강호관 감 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 장점: [\u0026quot;\u0026quot;] 완료: [] 미래를 바꾼 아홉가지 알고리즘[1판]\n분야: 알고리즘 작가: 존 맥코믹 저 / 민병교 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 장점: [\u0026quot;\u0026quot;] 완료: [] 조엘 온 소프트웨어 - 유쾌한 오프라인 블로그[1판]\n분야: 사고(思考) 작가: 조엘 스폴스키 저 / 박재호, 이해영 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 장점: [\u0026quot;\u0026quot;] 완료: [] 자바의 신[2판]\n분야: 프로그래밍 언어 작가: 이상민 저 / 김성박, 박재성 감 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 타입스크립트 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 보리스 체르니 저 / 우정은 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 만들면서 배우는 리스프 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 콘래드 바스키 저 / 조태훈 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 마이크로서비스 아키텍처 구축[1판]\n분야: 설계 작가: 샘 뉴먼 저 / 정성권 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 프로그래밍 수련법[1판]\n분야: 프로그래밍 언어 작가: 브라이언 W. 커니핸, 롭 파이크 저 / 김정민, 장혜식, 신성국 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 맨머스 미신:소프트 공학에 관한 에세이[1판]\n분야: 사고(思考) 작가: 프레더릭 브룩스 저 / 강중빈 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 테스트 주도 개발[1판]\n분야: 사고(思考) 작가: 켄트 백 저 / 김창준, 강규영 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 다양한 언어로 배우는 정규표현식[1판]\n분야: 도구 작가: 신야 료마, 스즈키 유스케, 타카타 켄 저 / 김완섭 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 리팩토링[1판]\n분야: 사고(思考) 작가: 마틴 파울러 저 / 김지원 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 테스트 주도 개발로 배우는 객체 지향 설계와 실천[1판]\n분야: 사고(思考) 작가: 스티브 프리먼, 냇 프라이스 저 / 이대엽 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] HTML 5 첫걸음[1판]\n분야: 마크업 언어 작가: 브루스 로슨 , 레미 샵 저 / 정유한 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] THE BOOK OF CSS3[1판]\n분야: 마크업 언어 작가: 피터 개스통 저 / 동준상 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 데이터 중심 애플리케이션 설계[1판]\n분야: 설계 작가: 마틴 클레프만 저 / 정재부, 김영준, 이도경 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] uml 실전에서는 이것만 쓴다[2판]\n분야: 설계 작가: 로버드 c. 마틴 저 / 이용원, 정지호 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] JavaScript Web Applications[1판]\n분야: 프로그래밍 언어 작가: 알렉스 맥카우 저 / 우정은 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 성능 최적화[1판]\n분야: 프로그래밍 언어 작가: 니콜라스 자카스 저 / 한선용 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 프로그래밍 얼랭[1판]\n분야: 프로그래밍 언어 작가: 조 암스트롱 저 / 김석준 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 인공지능 논리 Prolog 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: W.F Clocksin, C.S. Mellish 저 / 배재학 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트는 왜 그 모양일까?[1판]\n분야: 프로그래밍 언어 작가: 더글러스 크락포드 저 / 박수현 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 개론[1판]\n분야: 프로그래밍 언어 작가: 마레인 하버비케 저 / 이대엽 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 함수형 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 마이클 포거스 저 / 우정은 역 / 장경석 감 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 함수형 자바스크립트 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 유인동 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 닌자 비급[1판]\n분야: 프로그래밍 언어 작가: 존 레식, 베어 바이볼트 저 / 강대명, 깅광훈, 이의호 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트를 말하다[1판]\n분야: 프로그래밍 언어 작가: 악셀 라우슈마이어 저 / 한선용 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 프로 자바스크립트 테크닉[1판]\n분야: 프로그래밍 언어 작가: 존 레식 저 / 송인철, 이동기, 이유원, 황인석 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] JavaScript Pattern[1판]\n분야: 프로그래밍 언어 작가: 스토얀 스테파노프 저 / 김준기, 변유진 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] CODE COMPLETE[2판]\n분야: 사고(思考) 작가: 스티브 맥코넬 저 / 서우석 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] TCP/IP 완벽 가이드[1판]\n분야: 네트워크 작가: Charles M. Kozierok 저 / 강유, 김진혁, 민병호, 박선재 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 퍼펙트 루비[1판]\n분야: 프로그래밍 언어 작가: 루비 서포터즈 저 / 김완섭 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 데이터베이스 개론[2판]\n분야: 데이터베이스 작가: 김연희 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 러닝 SQL[1판]\n분야: 데이터베이스 작가: 앨런 볼리외 저 / 류수미, 송희정 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 모두를 위한 PostgreSQL[1판]\n분야: 데이터베이스 작가: 정승호, 박성호, 한도형, 홍수민 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 가장 빨리 만나는 자바8[1판]\n분야: 프로그래밍 언어 작가: 카이 호스트만 저 / 신경근 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바 8 람다의 힘[1판]\n분야: 프로그래밍 언어 작가: 벤컷 수브라마니암 저 / 장독대 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 이펙티브 자바[2판]\n분야: 프로그래밍 언어 작가: 조슈아 블로크 저 / 이병준 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 헤드 퍼스트 디자인 패턴[1판]\n분야: 설계 작가: 에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠 저 / 서환수 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] DDD START![1판]\n분야: 사고(思考) 작가: 최범균 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바 ORM 표준 JPA 프로그래밍[1판]\n분야: 프레임워크 작가: 김영한 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] JUnit in Action[1판]\n분야: 테스트 작가: 김영한 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 코드로 배우는 스프링부트 웹 프로젝트[1판]\n분야: 프레임워크 작가: 구멍가게 코딩단 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 스프링 부트 쇼핑몰 프로젝트 with JPA[1판]\n분야: 프레임워크 작가: 변구훈 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 퍼펙트 루비 온 레일즈[1판]\n분야: 프레임워크 작가: 야마다 요시히로 저 / 윤인성 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 레일스와 함께하는 애자일 웹 개발[2판]\n분야: 프레임워크 작가: 샘 루비, 데이브 토머스, 데이비드 하이네마이어 핸슨 저 / 조성만, 조재혁 역 / 김석준 감 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 이것이 우분투 리눅스다[1판]\n분야: OS 작가: 우재남 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Real MySQL[1판]\n분야: 데이터베이스 작가: 이성욱 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 컴퓨터 프로그램의 구조와 해석[1판]\n분야: 컴퓨터 작가: 해럴드 애빌슨, 제럴드 제이 서스먼, 줄리 서스먼 저 / 김재우, 안윤호, 김수정, 김정민 역 / 이광근 감 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 코딩 더 매트릭스[1판]\n분야: 알고리즘 작가: 필립 클라인 저 / 마이클 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] HTTP 완벽 가이드[1판]\n분야: 알고리즘 작가: 데이빗 고울리, 브라이언 토티, 마조리 세이어, 세일루 레디, 안슈 아가왈 저 / 이응중, 정상일 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 한 권으로 배우는 Vue.js3[1판]\n분야: 프레임워크 작가: 김동혁 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 루비로 배우는 객체지향 디자인[1판]\n분야: 설계 작가: 샌디 메츠 저 / 박건하 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 소프트웨어 컨플릭트 2.0[1판]\n분야: 사고(思考) 작가: 로버트 L. 글래스 저 / 박재호, 이해영 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] CSS 완벽 가이드[1판]\n분야: 마크업 언어 작가: 에릭 마이어 저 / 남덕현, 이준, 연홍석, 정태영 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 리팩토링: 루비 에디션[1판]\n분야: 설계 작가: 마틴 파울러, 켄트 벡, 제이 필즈, 셰인 하비 저 / 김지원 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 완벽 가이드[2판]\n분야: 프로그래밍 언어 작가: 데이비드 플래너건 저 / 구경택, 박경욱, 변칭훈, 이의호 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 프론트엔드 개발자를 위한 자바스크립트 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 니콜라스 자카스 저 / 한선용 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Node.js 교과서[1판]\n분야: 프로그래밍 언어 작가: 조현영 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] [리얼타임]JavaScript Promise[1판]\n분야: 프로그래밍 언어 작가: azu, 주우영 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바로 배우는 핵심 자료구조와 알고리즘[1판]\n분야: 자료구조 + 알고리즘 작가: 앨런 B 다우너 저 / 유동환 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바 웹을 다루는 기술[1판]\n분야: 프로그래밍 언어 작가: 이병승 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 처음 배우는 스프링 부트2[1판]\n분야: 프레임워크 작가: 김영재 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 오라클로 배우는 데이터베이스 입문[1판]\n분야: 데이터베이스 작가: 이지훈 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 훌륭한 프로그래머 되는 법[1판]\n분야: 사고(思考) 작가: 프트 구들리프 저 / 강전희, 남윤화, 안재덕, 최원재 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 토비의 스프링3.1[1판]\n분야: 프레임워크 작가: 이일민 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 유지보수 가능한 코딩의 기술 자바편[1판]\n분야: 프로그래밍 언어 작가: 주스트 뷔서, 파스칼 반 에크, 롭 반 더 리크, 실번 리갈 , 하시 위즌홀즈 저 / 이일웅 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 실전 스프링 부트 웹 개발[1판]\n분야: 프레임워크 작가: 향단코드 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 모두의 SQL[1판]\n분야: 데이터베이스 작가: 김도연 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 스프링 부트 코딩 공작소[1판]\n분야: 프레임워크 작가: 크레이그 월즌 저 / 황인서 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Do it! 자료구조와 함께 배우는 알고리즘 입문[1판]\n분야: 자료구조 + 알고리즘 작가: 시바타 보요 저 / 강민 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 실습으로 배우는 SQL injection[1판]\n분야: 데이터베이스 작가: 한승협 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 데이터베이스(워크북 포함)[1판]\n분야: 데이터베이스 작가: 정재화, 정순영 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 컴퓨터구조[1판]\n분야: 컴퓨터 작가: 김형근, 손진곤 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 운영체제[1판]\n분야: OS 작가: 김진욱, 관덕훈, 이병래 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 기계는 어떻게 생각하는가?[1판]\n분야: 사고(思考) 작가: 숀 게리시 저 / 이수겸 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 가장 빨리 만나는 Go 언어[1판]\n분야: 프로그래밍 언어 작가: 이재홍 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 러닝 PHP[1판]\n분야: 프로그래밍 언어 작가: 데이비드 스클라 저 / 점병열 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 함수형 사고[1판]\n분야: 프로그래밍 언어 작가: 닐 포드 저 / 김재완 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 함수형 언어 산책[1판]\n분야: 프로그래밍 언어 작가: 이동규 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 생애 첫 SQL With 제코베[1판]\n분야: 데이터베이스 작가: 이호준, 김해원, 김유진, 차경림, 김영희 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 패턴과 테스트[1판]\n분야: 프로그래밍 언어 작가: 래리 스펜서, 세스 리처즈 저 / 이일웅 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 리얼월드 HTTP[1판]\n분야: 네트워크 작가: 시부카와 요시키 저 / 김성훈 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] [리얼타임]처음 시작하는 Sass[1판]\n분야: 마크업 언어 작가: 김유리, 방지은, 양주희, 정대영, 홍보라 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] CSS 슈퍼파워 Sass로 디자인하라[1판]\n분야: 마크업 언어 작가: 양용석 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 코딩의 기술[1판]\n분야: 프로그래밍 언어 작가: 조 모건 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] [리얼타임]You Don\u0026rsquo;t know JS:this와 각체 프로토타입[1판]\n분야: 프로그래밍 언어 작가: 카일 심슨 저 / 이일웅 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] [리얼타임]You Don\u0026rsquo;t know JS:스코프와 클로저[1판]\n분야: 프로그래밍 언어 작가: 카일 심슨 저 / 최병헌 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 함수형 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 루이스 아텐시오 저 / 이일웅 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 자바스크립트 UI 개발과 Jindo 프레임워크[1판]\n분야: 프로그래밍 언어 작가: 박재성, 손병대 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 디스커버리 Go 언어[1판]\n분야: 프로그래밍 언어 작가: 염재현 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Go 인 액션[1판]\n분야: 프로그래밍 언어 작가: 윌리엄 케네디, 브라이언 케텔슨, 에릭 St. 마틴 저 / 장현희 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 실전 자바 소프트웨어 개발\n분야: 프로그래밍 언어 작가: 라울-게이브리얼 우르마, 리처드 워버턴 저 / 우정은 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Head First Go\n분야: 프로그래밍 언어 작가: 제이 맥가브렌 저 / 권민재 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 알고리즘 도감\n분야: 알고리즘 작가: 이시다 모리테루, 미야자키 쇼이치 저 / 김완섭 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 누워서 읽는 알고리즘\n분야: 알고리즘 작가: 임백준 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Go 언어 웹 프로그래밍 철저 입문\n분야: 프로그래밍 언어 작가: 장재휴 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 구입 고려 중 CSS 완벽 가이드[2판]\n분야: 마크업 언어 작가: 에릭 마이어, 에스텔 웨일 저/ 한선용 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 다양한 예제로 배우는 CSS 설계 실전 가이드[1판]\n분야: 마크업 언어 작가: 한다 아츠시 저 / 김연수 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 오브젝트\n분야: 설계 작가: 조영호 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 도메인 주도 설계 첫걸음\n분야: 설계 작가: 블라드 코노노프 저 / 김민석, 오창윤 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 도메인 주도 설계 철저 입문\n분야: 설계 작가: 나루세 마사노부 저 / 심효섭 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 도메인 주도 설계\n분야: 설계 작가: 에릭 에반스 저 / 이대엽 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 엘레강트 오브젝트\n분야: 설계 작가: 조영호 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 도메인 주도 설계 핵심\n분야: 설계 작가: 반 버논 저 / 박현철, 전장호 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 도메인 주도 개발 시작하기[2판]\n분야: 설계 작가: 최범균 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] PostgreSQL로 시작하는 SQL 코딩입문 Part 01 기본편\n분야: 데이터베이스 작가: 박상용 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] PostgreSQL로 시작하는 SQL 코딩입문 Part 02 활용편\n분야: 데이터베이스 작가: 박상용 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 실용 SQL\n분야: 데이터베이스 작가: 앤서니 드바로스 저 / 임소정, 강민혁 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] Head First SQL : 효율적인 DB 관리를 위한 SQL 학습법\n분야: 데이터베이스 작가: 린 베일리 저 / 박종걸 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 쏙쏙 들어오는 함수형 코딩\n분야: 설계 작가: 에릭 노먼드 저 / 김은민 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 코딩 호러의 이펙티브 프로그래밍\n분야: 사고(思考) 작가: 제프 앳우드 저 / 임백준 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] 읽기 좋은 코드가 좋은 코드다\n분야: 사고(思考) 작가: 더스틴 보즈웰, 트레버 파우커 저 / 임백준 역 별점: 회독: 0 읽을 타이밍: 장점: [\u0026quot;\u0026quot;] 단점: [\u0026quot;\u0026quot;] 완료: [] DONE 사용자를 생각하게 하지 마![2판]\n분야: UI/UX 작가: 스티브 크룩 저 / 이미령 역 별점: 5 회독: 1 읽을 타이밍: UI/UX에 대한 관심이 생겼을 떄 장점: [\u0026ldquo;얇다.\u0026rdquo;, \u0026ldquo;책 한권에 엄청난 유머가 담겨있다.\u0026rdquo;, \u0026ldquo;처음으로 UI/UX 관련 책을 읽었음에도 불구하고 거의 모든 내용이 이해되었다.\u0026rdquo;] 단점: [\u0026ldquo;없다.\u0026rdquo;] 완료: [2023] 프로젝트가 서쪽으로 간 까닭은[1판]\n분야: 사고(思考) 작가: 다수의 작가 별점: 4 회독: 2 읽을 타이밍: 프로젝트가 잘못된 방향으로 가고 있는 것 같은 경우 장점: [\u0026ldquo;프로젝트가 잘못되고 있는 여러 패턴을 확인 가능.\u0026rdquo;] 단점: [\u0026ldquo;해결 방법이 명확하지 않음\u0026rdquo;] 완료: [2023, 2023] 함께 자라기[1판]\n분야: 사고(思考) 작가: 김창준 별점: 5 회독: 3 읽을 타이밍: 개인적으로 노력해서 기술적으로 상당한 레벨까지 도달했다고 느꼈을 때 장점: [\u0026ldquo;다른 사람들과 함께 성장한다는 의미를 알려준다.\u0026rdquo;, \u0026ldquo;혼자만으로는 한계가 있다는 점을 알려준다.\u0026rdquo;] 단점: [\u0026ldquo;없다.\u0026rdquo;] 완료: [2023, 2023, 2023] 대체 뭐가 문제야[1판]\n분야: 사고(思考) 작가: 제럴드 M. 와인버그 별점: 5 회독: 3 읽을 타이밍: 새로운 방식으로 생각하고 싶은 경우 장점: [\u0026ldquo;문제에 대한 새로운 시각으로 접근 가능.\u0026rdquo;] 단점: [\u0026ldquo;없다.\u0026rdquo;] 완료: [2023, 2023, 2023] 그로스 해킹[1판]\n분야: 사고(思考) 작가: 라이언 홀리데이 별점: 4 회독: 2 읽을 타이밍: 어떠한 서비스를 만들고 싶은 경우 장점: [\u0026ldquo;얇기 때문에 그로스 해킹이 핵심 내용만 쉽게 알 수 있음\u0026rdquo;] 단점: [\u0026ldquo;사례에 대한 예시를 조금 더 넣어줬으면 좋았을 것 같다.\u0026rdquo;] 완료: [2023, 2023] 객체지향의 사실과 오해 - 역할, 책임, 협력 관점에서 본 객체지향[1판]\n분야: 사고(思考) 작가: 조영호 별점: 4 회독: 2 읽을 타이밍: 객체지향에 대해서 생각해 보고 싶은 경우 장점: [\u0026ldquo;기존 객체지향에 대해서 생각하던 관점이 바뀐다.\u0026rdquo;] 단점: [\u0026ldquo;나의 객체지향에 이해가 딸리기 때문에 아직 판단을 못하겠다.\u0026rdquo;] 완료: [2022] 헤드 퍼스트 자바스크립트 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 에릭 프리먼, 엘리자베스 롭슨 공저 / 강권학 역 별점: 2 회독: 1 읽을 타이밍: 현재(2022) 기준으로 읽지 마라 장점: [\u0026ldquo;재미있는 프로그래밍 책\u0026rdquo;] 단점: [\u0026ldquo;너무 옛날 기술로 써져있음\u0026rdquo;] 완료: [2022] 누구나 쉽게 배우는 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 닉 모건 저 / 김태곤, 이미령 역 별점: 3 회독: 1 읽을 타이밍: 처음 프로그래밍을 배우는 경우 장점: [\u0026ldquo;처음 프로그래밍을 배우는 사람도 간단하게 읽을 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;JavaScript가 HTML에 종속되어 있다는 관념이 생길 가능성이 있음.\u0026rdquo;] 완료: [2022] 실용주의 프로그래머[3판]\n분야: 사고(思考) 작가: 앤드류 헌트, 데이비드 토머스 저 / 김창준, 정지호 역 별점: 5 회독: 1 읽을 타이밍: 좋은 프로그래머가 되고 싶을 때 장점: [\u0026ldquo;어떻게 하면 좋은 프로그래머가 될 수 있는지 고민하는 시간을 갖을 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;현재 기준(2022년) 예시에서 나온 기술이 조금 낡은 경향이 있다. 신판 내주세요!(20주년 기념판 나왔다!)\u0026rdquo;] 완료: [2022] [리얼타임] 개발자를 위한 하룻밤에 읽는 Go 언어 이야기[1판]\n분야: 사고(思考) 작가: 신재용 별점: 3 회독: 1 읽을 타이밍: Go를 배울 이유를 찾고 있는 경우 장점: [\u0026ldquo;Go에 대한 뽕을 충전 할 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;Go를 해야한다.\u0026rdquo;] 완료: [2022] 프로그래머, 수학의 시대\n분야: 사고(思考) 작가: 이재현, 이정설 별점: 3 회독: 1 읽을 타이밍: 수학뽕을 맞고 싶은 경우 장점: [\u0026ldquo;역시 수학은 필요하다고 생각하는 계기가 된다.\u0026rdquo;] 단점: [\u0026ldquo;이미 늦었다고 생각하면 포기하고 싶어진다.\u0026rdquo;] 완료: [2022] 테스트 주도 개발[1판]\n분야: 사고(思考) 작가: 채수원 별점: 4 회독: 1 읽을 타이밍: TDD를 사용하고 싶은 경우 장점: [\u0026ldquo;TDD에 대해서 고민 할 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;사용하고 있는 도구가 현재(2022년) 기준 조금 낡았다.(TDD의 본질적인 내용은 바뀌지 않으므로 별로 크게 상관 없는데 조금 아쉬움, 신판 내주세요!)\u0026rdquo;] 완료: [2022] 프로그래머로 사는 법[1판]\n분야: 사고(思考) 작가: 샘 라이트스톤 저 / 서환수 역 별점: 5 회독: 1 읽을 타이밍: 좋은 프로그래머가 되고 싶을 때 장점: [\u0026ldquo;위대한 프로그래머들의 좋은 이야기를 들을 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;간단한 내용의 책을 읽고 싶은 사람들에게는 조금 내용이 많을 수 있다.\u0026rdquo;] 완료: [2022] 임백준의 대살개문[1판]\n분야: 사고(思考) 작가: 임백준 별점: 4 회독: 1 읽을 타이밍: 다른 프로그래머는 무슨 생각을 하고 있나 궁금할 경우 장점: [\u0026ldquo;조인트 안까이고 싶으니깐 벌크업해야지라고 생각해 운동하게 되었다.\u0026rdquo;] 단점: [\u0026ldquo;한국 탈출하고 싶어진다.(난 탈출했다.)\u0026rdquo;] 완료: [2022] 리눅스 커맨드라인 완벽 입문서[1판]\n분야: 도구 작가: 윌리엄 E. 샤츠 주니어 저 / 이종우, 정영신 역 별점: 5 회독: 1 읽을 타이밍: Shell에서 작업하고 싶은 경우 장점: [\u0026ldquo;Shell 사용법에 대해서 친절하게 배울 수 있다.\u0026rdquo;, \u0026ldquo;책 표지의 로봇이 커맨드를 먹고 있는 디자인이 좋다.\u0026rdquo;] 단점: [\u0026ldquo;없다.\u0026rdquo;] 완료: [2022] 스프링 부트와 AWS로 혼자 구현하는 웹 서비스[1판]\n분야: 프레임워크 작가: 이동욱 별점: 3 회독: 1 읽을 타이밍: Spring boot를 처음 사용해보는 경우 장점: [\u0026ldquo;간단하게 Spring boot를 움직여 볼 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;간단하게 해보는 정도에서 그치기 때문에 깊은 내용은 알 수 없다.\u0026rdquo;] 완료: [2022] Do it! 타입스크립트 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 전예홍 별점: 5 회독: 1 읽을 타이밍: Typescript와 FP를 동시에 배우고 싶은 경우 장점: [\u0026ldquo;Typescript와 FP를 동시에 배울 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;모나드 나온다.(초보자들 도망가는 소리가 여기까지 들려온다.)\u0026rdquo;] 완료: [2022] 개발자의 글쓰기[1판]\n분야: 사고(思考) 작가: 김철수 별점: 4 회독: 1 읽을 타이밍: 프로그래머는 글을 잘 쓰는게 중요하다고 생각한 경우 장점: [\u0026ldquo;어떻게 하면 좋은 글을 쓸 수 있는지 생각할 수 있다.\u0026rdquo;] 단점: [\u0026quot;(개인적) 외국에서 일하고 있기 때문에 배운것을 사용해보지 못해서 평가를 못내리겠다.\u0026quot;] 완료: [2022] 소프트웨어 장인[1판]\n분야: 사고(思考) 작가: 산드로 만쿠소 저 / 권오인 역 별점: 4 회독: 1 읽을 타이밍: 좋은 프로그래머가 되고 싶은 경우 장점: [\u0026ldquo;직업정신에 대해서 생각 할 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;판타지 세계의 이야기인가 싶을 때가 있다.\u0026rdquo;] 완료: [2022] 모두의 네트워크[1판]\n분야: 네트워크 작가: 미즈구치 카츠야 별점: 4 회독: 1 읽을 타이밍: 네트워크에 대한 지식이 아무것도 없을 때 간략하게 전체를 살펴볼 수 있음 장점: [\u0026ldquo;네트워크에 관해서 간략하게 살펴 볼 수 있음\u0026rdquo;] 단점: [\u0026ldquo;정말로 간략하게 살펴본다.\u0026rdquo;] 완료: [2022] 해커와 화가[1판]\n분야: 사고(思考) 작가: 폴 그레이엄 저 / 임백준, 정희 역 별점: 4 회독: 1 읽을 타이밍: 성공한 프로그래머는 어떻게 생각했는지 듣고 싶은 경우 장점: [\u0026ldquo;미래를 어떻게 저렇게 잘 애측했는지 감탄한다.\u0026rdquo;] 단점: [\u0026ldquo;LISP를 배우지 않으면 좋은 프로그래머가 될 수 없을 것 같은 느낌이 남아서 찜찌하다.(LISP 책 샀다.)\u0026rdquo;] 완료: [2022] Java의 정석[3판]\n분야: 프로그래밍 언어 작가: 남궁성 별점: 4 회독: 1 읽을 타이밍: 자바를 배우고 싶은 경우. 장점: [\u0026quot;??\u0026quot;] 단점: [\u0026quot;??\u0026quot;] 완료: [2022] 코어 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 정재남 별점: 5 회독: 1 읽을 타이밍: JavaScript에 대해서 깊게 배우고 싶은 경우 장점: [\u0026ldquo;자바스크립트가 내부에서 어떻게 돌아가는지 이해할 수 있게 되었다.\u0026rdquo;] 단점: [\u0026ldquo;없다.\u0026rdquo;] 완료: [2022] Do it! 자바 프로그래밍 입문[1판]\n분야: 프로그래밍 언어 작가: 박은종 별점: 3 회독: 1 읽을 타이밍: Java에 대해 배우고 싶은 초보자 장점: [\u0026ldquo;자바의 기본적인 사용법을 배울 수 있다.\u0026rdquo;, \u0026ldquo;파일에 이름을 지정해줘서 따라서 코딩해보기 쉽다.\u0026rdquo;] 단점: [\u0026ldquo;Enum과 같은 중요한 개념이 없기 때문에 반드시 다른 책도 읽어볼 필요가 있다.\u0026rdquo;] 완료: [2021] 고양이도 할 수 있는 Vue.js[1판]\n분야: 프레임워크 작가: mio 별점: 4 회독: 1 읽을 타이밍: Vue.js를 사용하고 있는 경우 장점: [\u0026ldquo;필요한 기능이 있는 경우 그 페이지로 이동해서 빠르게 볼 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;사전식임으로 무언가를 완성하지는 않는다.\u0026rdquo;] 완료: [2021] Do it! Vue.js 입문[1판]\n분야: 프레임워크 작가: 정기효 별점: 3 회독: 1 읽을 타이밍: Vue.js를 처음 사용하는 경우 장점: [\u0026ldquo;자바의 기본적인 사용법을 배울 수 있다.\u0026rdquo;, \u0026ldquo;파일에 이름을 지정해줘서 따라서 코딩해보기 쉽다.\u0026rdquo;] 단점: [\u0026ldquo;실제로 뭔가 만들 수는 없었다.\u0026rdquo;] 완료: [2021] 데이터베이스 첫걸음[1판]\n분야: 데이터베이스 작가: 기무라 메이지, 미크 저 / 박주항 역 별점: 5 회독: 1 읽을 타이밍: 데이터 베이스를 처음 배우는 사람에게 장점: [\u0026ldquo;단순히 데이터 베이스 사용법만이 아니라 왜 이 데이터 베이스를 사용하는지에 대해서 생각 할 수 있게 한다.\u0026rdquo;] 단점: [\u0026ldquo;첫걸음으로 끝나는게 아쉽다. 두번째 걸음도 같이 가고 싶은 책이다.\u0026rdquo;] 완료: [2021] 자바스크립트 핵심 가이드[1판]\n분야: 프로그래밍 언어 작가: 더글라스 크락포드 저 / 김명신 역 별점: 5 회독: 1 읽을 타이밍: JavaScript에 대해서 깊게 알고 싶은 경우 장점: [\u0026ldquo;JavaScript의 깊은 부분에 대해서 이해 할 수 있다.\u0026rdquo;, \u0026ldquo;프로그래밍 언어에 관한 관점을 세울 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;현재(2021) 시점으로 기술이 낡았다.\u0026rdquo;] 완료: [2021] 인사이드 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 고현준, 송형주 별점: 4 회독: 1 읽을 타이밍: JavaScript에 대해서 깊게 이해하고 싶은 경우 장점: [\u0026ldquo;JavaScript의 동작에 대해서 깊게 이해 할 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;ES6의 기능을 거의 사용 가능한 현재(2021) 기준으로 조금 낡았다.(신판 내주세요!)\u0026rdquo;] 완료: [2021] 손이 먼저 반응하는 Practical Vim[1판]\n분야: 도구 작가: 드류 네일 저 / 김용균 역 별점: 5 회독: 1 읽을 타이밍: vim에 대해서 깊게 생각하고 사용하고 싶은 경우 장점: [\u0026ldquo;vim을 어떻게 사용하는게 효율적인지 알 수 있다.\u0026rdquo;, \u0026ldquo;shell을 전동 도구인 vim을 표현한 것 같은 표지 디자인이 좋다.\u0026rdquo;] 단점: [\u0026ldquo;종교가 vim으로 변할 수 있다.\u0026rdquo;] 완료: [2021] 손에 잡히는 Vim[1판]\n분야: 도구 작가: 김선영 별점: 3 회독: 1 읽을 타이밍: vim을 사용하고 싶은 경우 장점: [\u0026ldquo;vim에 대해 간단하게 배울 수 있다.\u0026rdquo;, \u0026ldquo;cheet sheet가 보기 좋다.\u0026rdquo;, \u0026ldquo;키보드를 연주하는 것 같은 표지 디자인이 좋다.\u0026rdquo;] 단점: [\u0026ldquo;굉장히 기초적인 내용만 나와있기 때문에 더욱 깊은 활용법은 다른 자료를 찾아봐야한다.\u0026rdquo;] 완료: [2021] 만화로 배우는 리눅스 시스템 관리 2권[1판]\n분야: 도구 작가: Piro 저 / 서수환 역 별점: 4 회독: 1 읽을 타이밍: Shell을 사용해서 작업을 하고 싶은 경우 장점: [\u0026ldquo;1권 보다 깊은 내용을 배울 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;아직 여기까지 이해 할 수 없다, 나중에 다시 읽어보도록 하자.\u0026rdquo;] 완료: [2021] 만화로 배우는 리눅스 시스템 관리 1권[1판]\n분야: 도구 작가: Piro 저 / 서수환 역 별점: 4 회독: 2 읽을 타이밍: Shell을 사용해서 작업을 하고 싶은 경우 장점: [\u0026ldquo;만화다.\u0026rdquo;] 단점: [\u0026ldquo;만화다.\u0026rdquo;] 완료: [2021] 뇌를 자극하는 Java 프로그래밍[1판]\n분야: 프로그래밍 언어 작가: 김윤명 별점: 2 회독: 1 읽을 타이밍: 현재(2021) 시점으로는 읽지 않는 것을 추천한다. 장점: [\u0026ldquo;아마 이 책이 나왔을 당시에는 좋은 책이었다고 생각한다.\u0026rdquo;] 단점: [\u0026ldquo;현재(2021) 시점에는 많이 낡은 내용들이 있다.\u0026rdquo;] 완료: [2021] 러닝 자바스크립트[1판]\n분야: 프로그래밍 언어 작가: 이선 브라운 저 / 한선용 역 별점: 5 회독: 1 읽을 타이밍: JavaScript의 여정을 떠나는 누구나, 심지어 다른 JavaScript의 읽은 사람도 장점: [\u0026ldquo;ES6를 빠르게 살펴 볼 수 있었다.\u0026rdquo;] 단점: [\u0026ldquo;뒷 부분의 비동기는 초보자가 보기에 조금 어려울 수 있다.\u0026rdquo;] 완료: [2021] Do it! 웹 프로그래머를 위한 자바스크립트 기본편[1판]\n분야: 프로그래밍 언어 작가: 고경희 별점: 3 회독: 1 읽을 타이밍: 개인 홈페이지를 만들어 간단한 JavaScript를 작성하고 싶은 경우 장점: [\u0026ldquo;간단하게 JavaScript가 무엇인지 확인 할 수 있다.\u0026rdquo;] 단점: [\u0026ldquo;JavaScript가 HTML에 종속되어 있다고 생각하기 쉽다.\u0026rdquo;, \u0026ldquo;Do it 시리즈가 공유하는 단점인 깊은 내용의 부재\u0026rdquo;] 완료: [2020] 분야 리스트 OS UI/UX 네트워크 데이터베이스 도구 마크업 언어 사고(思考) 설계 알고리즘 자료구조 컴퓨터 프로그래밍 언어 프레임워크 테스트 "
            }
    
        ,
            {
                "id": 65,
                "href": "https://coder-shin.github.io/post/javascript/",
                "title": "자바스크립트(JavaScript)",
                "section": "post",
                "date" : "2023.02.14",
                "body": "나의 해석 자바와 이름이 비슷하지만 자바의 스크립트 버전은 아니다.\n인용 팁 [[javascript를 이용해서 사용자가 어떤 디바이스를 사용해서 접속하고 있는지 알아보기]] 관련 링크 문법 [[include]]{포함(include)} [[spread operator]]{전개 구문(spread operator)} [[template literals]]{(템플릿 리터럴(template literals)} [[data structure]]{자료구조(data structure)} [[variable]]{변수(variable)} [[array]]{배열(array)} [[object]]{객체(object)} "
            }
    
        ,
            {
                "id": 66,
                "href": "https://coder-shin.github.io/post/home/",
                "title": "index",
                "section": "post",
                "date" : "2023.02.14",
                "body": "소프트웨어 공학(software engineering) [[oop]]{객체 지향 프로그래밍(OOP)} [[fp]]{함수형 프로그래밍(FP)} 프로그래밍 언어(programming language) [[c]]{C} [[java]]{자바(Java)} [[javascript]]{자바스크립트(JavaScript)} 마크업 언어(markup language) [[html]]{HTML} 데이터베이스(database) [[database]]{데이터베이스(Database)} 컴퓨터 기초(computer basic) [[data structure]]{자료구조(data structure)} 정보 [[books]]{책(books)} [[words]]{용어(words)} [[sites]]{사이트(sites)} "
            }
    
        ,
            {
                "id": 67,
                "href": "https://coder-shin.github.io/about/",
                "title": "코더 신씨",
                "section": "",
                "date" : "0001.01.01",
                "body": "Me 웹 어플리케이션 개발자입니다. 하드웨어는 키보드에만 관심있습니다. 소프트웨어는 기본적으로 TUI를 선호합니다. 변하지 않는 지식을 배우기 위해 노력 중입니다. Skills 아래의 내용은 어디까지나 주관적인 판단입니다. Javascript =\u0026gt; 구글신 없이도 왠만한 질문은 다 대답할 수 있습니다. Java =\u0026gt; 구글신과 함께라면 잘 할 수 있습니다. SQL =\u0026gt; 구글신과 함께라도 모르는게 많습니다. Shell =\u0026gt; Shell은 나의 친구! Back-end =\u0026gt; 회사 사람들이 너무 잘해서, 오히려 모르는게 많습니다. Front-end =\u0026gt; 회사 사람들이 많이 질문해 주셔서, 여러 상황에 대응 가능합니다. Database =\u0026gt; 회사 사람들이 정말 너무 잘해서, 거의 모릅니다.(최근 공부 중 입니다.) UI/UX =\u0026gt; 회사 사람들 중 할 수 있는 사람이 없어서, 제가 공부 중 입니다. Blog 블로그의 모든 글은 WTFPL 라이선스 적용됩니다. 복사해서 다른 곳으로 옮기고 싶으면 마음껏 옮기세요. 틀린 내용이 있으면 지적 해주세요. Experience 2023 프로젝트 관리용 웹 어플리케이션 개발(angular, spring) 2022 프로젝트 관리용 웹 어플리케이션 개발(angular, spring) 자사 웹 어플리케이션 개발(vue, spring) 자사 웹 페이지 갱신(vue, spring) 채용 관련 웹 어플리케이션 보수 및 개발(spring) 2021 자사 웹 어플리케이션 개발(vue, spring) 소규모 식당 페이지 작성(vue, go) 채용 관련 웹 어플리케이션 보수 및 개발(spring) 2020 대규모 프로젝트 개발(ruby on rails) 사내 교육 2019 사내 교육 "
            }
    
]
